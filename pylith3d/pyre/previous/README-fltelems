I envision 3 different types of fault that will eventually be included
in Pylith, including 2 that are already present:

1.  Split node faults:  This is the finite element equivalent of a
dislocation, and is probably the simplest of the 3 fault types.  It
does not add any extra degrees of freedom to the problem.

2.  Slippery node faults:  These are faults in which movement occurs in
response to stress, and they will eventually include static and
kinematic friction, and possibly some other behavior as well.  These
faults can presently be implemented in one of two ways:
a.  The slip direction is specified a priori, in which case a single
new (differential) degree of freedom is assigned in the specified
direction.
b.  The slip direction is determined by the fault orientation as well
as the stress field.  In this case, a slip plane is first determined
by finding a best-fit plane through the node in question and its
neighbors on the fault.  A local coordinate rotation is then performed
so that two coordinate axes lie in that plane, and two new differential
degrees of freedom are added for movement in that plane.

3.  Slide surfaces:  These do not exist yet in Pylith.  They are
based on the formulations used in the LLNL NIKE (and I think also in
DYNA) codes.  This formulation, unlike the two previous formulations,
does not require matching nodes on either side of the fault.  It is
probably more suitable for large deformation problems and problems
where it is difficult to provide a mesh with matching nodes on both
sides of the fault.  A penalty is applied for penetration of a node
through a face on the other side (I think a similar penalty can be
applied for the case of a fault with no opening for movement of a node
away from a face).  This method is more general (I think it could be
adapted to cover either split or slippery node problems), but it is
much more computationally expensive.  Right now, it is not a high
priority, because most of the problems of interest seem to be small
strain problems, and because it does not seem that difficult to create
a mesh with matching nodes.

As far as formulation these faults in terms of elements rather than
nodes, the simplest case to consider is probably split nodes.  A very
simplistic implementation would be a 2-node element (unless we want a
different type of element for every face type that could occur on a
fault).  Such an element would have zero length and volume (at least
for small strain problems).  I am assuming that we create a mesh where
a node on a fault consists of two coincident nodes (different node
numbers with the same coordinates).  The way I do split nodes right now,
the element would have to accomplish 3 primary tasks:

1.  Assign the same equation numbers to both nodes composing the
element.  Otherwise, with the way I have things set up now, the nodes
will end up with different equation numbers which is not desirable for
split nodes.  In my present version of the code, I don't think I have
an analogous operation that is performed on elements.  I believe the
only operations I perform that alter the equation numbers are:
a.  Remove equations for degrees of freedom with kinematic BC.
b.  Add equations for slippery nodes.

2.  In the outer time-stepping loop, apply displacements according to a
given time history.  Again, I don't think I have an element-level
operation that directly alters the global displacement array.

3.  Again in the outer time-stepping loop, I presently compute the
contribution of the split node displacements to the global internal
force vector (I do the same thing for kinematic BC).  There are 4
possible ways I can think of to deal with this:

a.  As part of the information available to a split-node element, it
could know the element numbers attached to the nodes on either side of
the fault, and compute these contributions to the internal force vector
on an element-by-element basis.  This requires formulation of an
element-level stiffness matrix for each element.  This is somewhat
analogous to how things are done now.

b.  Alternatively, the information available to the split-node elements
could include the equation numbers associated with either side of the
fault.  Thus, a certain set of equation numbers would be associated
with node 1 of a split-node element, and another set of equation numbers
would be associated with node 2.  In this way, the contributions to the
global internal force vector could be computed using the global
stiffness matrix.

c.  Do nothing.  If I am willing to accept an iterative solution for
any type of problem, the contributions to the internal force vector will
be computed at the end of the first iteration, when strains and stresses
are computed.

d.  I just thought of another possiblity.  Any element with
kinematically-specified BC (this would include regular kinematic BC as
well as split node BC) could be flagged.  This subset of elements could
be looped over once all displacements have been assigned for the time
step to give the total contribution to the internal force vector.


The 2-node element would not be appropriate for slide surfaces.  In this
case something else would have to be done.  The 2-node element might
make bookkeeping easier in some cases, for example at fault
intersections.  See the file "flt-int.pdf".
