#
#   Parameter file for use with program blockrot2.
#
# **********************************************************************
#
#   Global information:
#
#    nblocks = number of blocks for this problem.
#    nfaults = number of faults for this problem.
#    cscale  = coordinate scaling factor for information from UCD file.
#    dipcut  = cutoff dip value (degrees) to determine whether dip-slip
#              movement will occur.  Points with local dip less than
#              this value will have dip-slip movement.
#
#   nblocks    nfaults    cscale    dipcut
#-----------------------------------------------------------------------
       4          3        1.0d0     75.0d0
#-----------------------------------------------------------------------
#
#   Rotation pole info:
#
#     For each block, enter the following info:
#       blocknum(i) = Block number for this pole.
#       polex(i)    = X-coordinate defining rotation pole location.
#       poley(i)    = Y-coordinate defining rotation pole location.
#       poler(i)    = Rotation amount in degrees CCW.
#
#     Pole locations are with respect to a user-defined reference frame.
#     Note that pole locations should be given in mks units (meters),
#     and that the cscale value above should also yield units of meters
#     when applied to the UCD file containing nodal coordinates.
#
#  blocknum(i)  polex(i)    poley(i)    poler(i),  i=1,nblocks
#-----------------------------------------------------------------------
     1         -1.8d6     -4.7d6    1.0d-5
     2          1.8d6      4.7d6    1.0d-5
     3          0.0d0      0.0d0    0.0d0
     4          0.0d0      0.0d0    0.0d0
# poles above should yield approximately equal amounts of strike-slip
# and dip-slip movement on the fault between blocks 1 and 2.  Blocks 3
# and 4 are chosen as the reference frame and so have no movement.
#-----------------------------------------------------------------------
#
#   Fault definition info:
#
#     For each 'fault' to be used, there must be an associated
#     definition file.  These should be listed in order of priority.
#     Nodes that lie on more than one fault will use the highest-listed
#     definition.
#
#     In addition to the file describing the fault, additional fault
#     definition info is required.  For each fault, a list of possible
#     block definitions is required.  Again, the highest-listed block
#     definition is the one that is used.
#
#     For each fault, we require the following info:
#
#     numdefs(i)   = number of fault definitions for this fault
#     block1(j,i)  = fault-bounding block toward which the normal points
#     block2(j,i)  = fault-bounding block from which the normal points
#     history(j,i) = load history to be associated with this definition
#     faultfile(i) = file containing fault definition info for this
#                    fault
#     j=1,numdefs(i),i=1,nfaults
#
#-----------------------------------------------------------------------
        1
        1            2            1
"fault07_01_02.flt_pylith"
# Highest priority is dipping boundary between blocks 1 and 2.
        1
        1            3            2
"fault10_01_03.flt_pylith"
# Next highest priority is vertical boundary between blocks 1 and 3.
        1
        2            4            3
"fault11_02_04.flt_pylith"
# Lowest priority is vertical boundary between blocks 2 and 4.
#-----------------------------------------------------------------------
