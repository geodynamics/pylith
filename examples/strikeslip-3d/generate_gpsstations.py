#!/usr/bin/env nemesis
"""Generate text file with list of fake GPS stations for Steps 4 and 5.

Command line arguments control the number of stations, distance, and random distribution.

The default values will generate the `gps_stations.txt` file that is provided.
"""

import argparse
import numpy

class App:
    """Application for generating list of fake GPS stations.
    """

    def __init__(self):
        """Constructor.
        """
        self.seed = 43589
        self.nstations = 50
        self.distribution = "gaussian"
        self.max_dist = 15.0e+3
        self.filename = "gps_stations.txt"

    def main(self):
        """Main entry point for application.
        """
        self._parse_command_line()
        points = self.create_points()
        self.write(points)

    def create_points(self):
        """Create random points for fake GPS stations.
        """
        numpy.random.seed(self.seed)
        if self.distribution == "gaussian":
            stdev = self.max_dist / 3.0
            x = numpy.random.normal(0.0, stdev, size=self.nstations)
            y = numpy.random.uniform(-self.max_dist, +self.max_dist, size=self.nstations)
            z = numpy.zeros(shape=numpy.shape(x))
        elif self.distribution == "uniform":
            x = numpy.random.uniform(-self.max_dist, +self.max_dist, size=self.nstations)
            y = numpy.random.uniform(-self.max_dist, +self.max_dist, size=self.nstations)
            z = numpy.zeros(shape=numpy.shape(x))
        else:
            raise ValueError(f"Unknown distribution '{self.distribution}'.")
        points = numpy.stack((x,y,z)).transpose()
        return points

    def write(self, points):
        """Write fake GPS stations to text file used by PyLith `OuputSolnPoints`.

        :param points: Numpy array (npoints, 3) with coordinates of stations.
        """
        with open(self.filename, "w") as fout:
            fout.write("# List of GPS stations generated by `generate_gpsstations.py` Python script.\n")
            st_id = 1
            for ist, point in enumerate(points):
                fout.write(f"ZZ.{ist+1:04d} {point[0]:8.1f} {point[1]:8.1f} {point[2]:8.1f}\n")

    def _parse_command_line(self):
        """Parse command line arguments.

        :returns: Command line arguments as argparse.Namespace.
        """
        parser = argparse.ArgumentParser()
        parser.add_argument("--random-seed", action="store", dest="seed", type=int, default=self.seed, help="Number of stations")
        parser.add_argument("--num-stations", action="store", dest="nstations", type=int, default=self.nstations, help="Number of stations")
        parser.add_argument("--distribution", action="store", dest="distribution", type=str, default=self.distribution, choices=["gaussian", "uniform"], help="Shape of distribution perpendicular to the fault")
        parser.add_argument("--max-dist", action="store", dest="max_dist", type=float, default=self.max_dist, help="Maximum distance for stations (3 standard deviations for gaussian distribution)")
        parser.add_argument("--filename", action="store", dest="filename", type=str, default=self.filename, help="Filename for station list")

        args = parser.parse_args()
        self.seed = args.seed
        self.nstations = args.nstations
        self.distribution = args.distribution
        self.max_dist = args.max_dist
        self.filename = args.filename

if __name__ == "__main__":
    App().main()


# End of file