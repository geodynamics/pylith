======================================================================
MAIN PRIORITIES (Brad)
======================================================================

FaultCohesiveKin::integrateJacobian()
  Need to prevent multiple contributions of orientation information for
  each vertex, because we want to use ADD_VALUES in updateOperator().

tests/1d/line2

  dislocation.cfg

solutioniovtk

  need to write each time step to a different file.

1. Simple tests with analytical solutions

   a. 2-D
     i. tri3 cells
       (1) axial compression
       (2) shear
     ii. quad4 cells
       (1) axial compression
       (2) shear
   b. 3-D
     i. tet4 cells
       (1) axial compression
       (2) shear
     ii. hex8 cells
       (1) axial compression
       (2) shear

5. Additional unit tests
  b. ElasticityExplicit and ElasticityImplicit
    i. multiple materials
    ii. constrained DOF

  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]

examples/templates

  containers
    faults.odb
    materials.odb

Check trapping of errors in reading spatialdata files.

======================================================================
SECONDARY PRIORITIES
======================================================================

Want to take advantage of symmetry and block structure of Jacobian
matrix when possible.

1. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

2. Implement absorbing boundary conditions

3. Reimplement SolutionIO.

   Follow implementation of MeshIO. SolutionIO implements extracting
   data from Sieve and calls virtual functions to write data.

   a. Reimplement SolutionIOVTK
   b. Implement SolutionIOHDF5

4. Implement MeshIOHDF5 & HDF5 (helper class)
   a. C++ objects
   b. unit tests at C++ level
   c. Python object (MeshIOHDF5)
   d. bindings
   e. unit tests at Python level

======================================================================
UNRESOLVED ISSUES
======================================================================

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

3. Distribute mesh/bc in scalable manner. 

  Inputs:
    * PETSc Mesh (with bc) (global on each processor)
    * number of processors
  Outputs:
    * PETSc Mesh on each processor (restricted to processor)

  [DONE]

4. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2?)
  Outputs:
    * PETSc Mesh (refined)

5. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  Note: I think this would give us incredible flexibility in selecting
  the appropriate discretization for a problem. For example, I think
  it would allow us to use spectral elements.

6. Trial run with quadratic elements

7. Trial run with fully interpolated mesh

======================================================================
QUESTIONS FOR LEIF
======================================================================

