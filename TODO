======================================================================
MAIN PRIORITIES (Brad)
======================================================================

FaultCohesiveKin::integrateJacobian()
  Need to prevent multiple contributions of orientation information for
  each vertex, because we want to use ADD_VALUES in updateOperator().

  Make slip directions consistent (left-lateral, fault-opening) across
  0-D, 1-D, and 2-D. Need to adjust slip for 1-D (orient2D) to be
  left-lateral instead of right lateral (p is lateral, q is out of
  plane, r is normal in order to be consistent with 2-D faults).

Dirichlet
  Add check for overly constrained points.
    (number of previously constrained DOF + number added <= fiberDim)

5. Additional unit tests
  b. ElasticityExplicit and ElasticityImplicit
    i. multiple materials
    ii. constrained DOF

  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]
    ii. Tests cases with multiple cohesive cells

examples/templates
  containers
    verify containers work

Check trapping of errors in reading spatialdata files.

======================================================================
SECONDARY PRIORITIES
======================================================================

Want to take advantage of symmetry and block structure of Jacobian
matrix when possible.

1. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

2. Implement absorbing boundary conditions

3. Reimplement SolutionIO.

   Follow implementation of MeshIO. SolutionIO implements extracting
   data from Sieve and calls virtual functions to write data.

   a. Reimplement SolutionIOVTK
   b. Implement SolutionIOHDF5

4. Implement MeshIOHDF5 & HDF5 (helper class)
   a. C++ objects
   b. unit tests at C++ level
   c. Python object (MeshIOHDF5)
   d. bindings
   e. unit tests at Python level

======================================================================
UNRESOLVED ISSUES
======================================================================

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

3. Distribute mesh/bc in scalable manner. 

  Inputs:
    * PETSc Mesh (with bc) (global on each processor)
    * number of processors
  Outputs:
    * PETSc Mesh on each processor (restricted to processor)

  [DONE]

4. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2?)
  Outputs:
    * PETSc Mesh (refined)

5. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  Note: I think this would give us incredible flexibility in selecting
  the appropriate discretization for a problem. For example, I think
  it would allow us to use spectral elements.

6. Trial run with quadratic elements

7. Trial run with fully interpolated mesh

======================================================================
QUESTIONS FOR LEIF
======================================================================

