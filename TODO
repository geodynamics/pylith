======================================================================
CURRENT ISSUES/PRIORITIES (1.7.0)
======================================================================

* --BUGS--

  DruckerPragerPlaneStrain, DruckerPrager3D
    High-frequency oscillation in dynamic simulations
    Extra plastic strain in quasi-static simulations
    Charles' test (which one?) shows same behavior in 2-D and 3-D, so error is 
      in both
  

* Manual

  - Order of tensor components for Xdmf files
  - Drucker Prager fit to yield surface
  - Slip-weakening healing parameter

* configure
  
  + Check compatibility of PyLith options with PETSc
    - HDF5
    - CUDA

* Module building

  + We want the _wrap.cxx files to work independent of PyLith and
    PETSc configure options (for example, with/without HDF5 and
    single/double precision).

* Green's functions

* 2-D materials

  + DruckerPragerPlaneStrain (Drucker-Prager plane strain ) [Charles]
  + PowerLawPlaneStrain (power law plane strain ) [Charles]

* Make nucleation for spontaneous rupture modular [BRAD]

  spatial and temporal variation in shear/normal stress for nucleation

* GenMaxwellQpQs [BRAD]

  2-D and 3-D versions
  Need to redo Maxwell time calculation. Use ratio.
  Create benchmark for test (compare against fk)

* Cleanup

    Add elasticPrestep() to Formulation (called from Problem)
    Remove solnIncr, keep setField()

======================================================================
1.8.0
======================================================================

* GPU utilization

  Finite-element integrations

  Modeled on snes/examples/tutorials/ex52.

  Refactor integration routine so that it uses batches rather than
  individual cells.

  + Implicit elasticity finite-element integration
  + Explicit elasticity finite-element integration

* Reimplement parameters to use PackedFields. [BRAD]

    Coordinate this with Matt's new Section stuff.

    Fields
    FieldsNew -> PackedFields
    SolutionFields [do this in multifields]
      Use PackedFields for acc, vel, disp(t+dt), disp(t), etc?
      Use Field for dispIncr(t->t+dt), residual(t)

* Higher order

* Coupling

* Field split.

    Add flag to material [default is false] for creating null vector
    When setting up solver, create null vector, and pass it to KSP

  Need to check performance of custom fault preconditioner.

* Line search [MATT]

  Line search should be improved to include the inequality constraints.



* Scalable distribution [MATT]

  + It appears that topology adjustment is not currently limiting the runs
  + Need a more memory scalable Distribution
    + Consider simple distribution, followed by cleanup
  + I think the Overlap structure is probably taking up all the memory
    + send/recvMeshOverlap is only used in completeConesV() to call SimpleCopy::copy()
      + Can we use a lighter-weight structure to sit in copy()?

  + Need ribbon around fault in order to develop algorithm

----------------------------------------
MISCELLANEOUS
----------------------------------------

* Memory model [MATT and BRAD]

  (1) The memory logging for distribution logs Creation and Stratification
  as Creation. Because we set the logging stages in PyLith and these
  are lumped together within the same Sieve routine, we cannot
  separate them.

  IntSections - Matt improved distribution to use allow IntSections
  over vertices or cells rather than vertices + cells. This cuts
  differences down to 75%.

  Need to check sum, because we may not be tracking deallocation.

----------------------------------------------------------------------
SECONDARY PRIORITIES
----------------------------------------------------------------------

* Paper

  General paper - focus on fault implementation
  - JGR, GGG
  
  geometry processing (adjusting topology)
  discretization (cohesive cells)
  model (Lagrange multipliers)
    Slip functions
    Fault constitutive models
  solver (saddle point)
    custom preconditioner
  benchmarks
    Savage and Prescott
    Dynamic
  real problem  

* Fault preconditioner [BRAD]

  FaultCohesiveLagrange::calcPreconditioner() [need unit test]

* Cleanup

    Consistent use of Schur complement

      + adjustSolnLumped()
        Compute Lagrange multipliers then displacements
      + form C as sparse matrix, use PETSc operations for computation
        (will work parallel)
      + Refactor friction sensitivity solve, fault preconditioner, and
        adjustSolnLumped()

* Optimization
  + inline methods (what isn't getting inlined) -Winline
  + Specialized elasticity integrator objects for Quad4, Hex8?
    - Add for lgdeform, implicit time integration?

* Explicit time step

  utility code
    Compute stable explicit time step
    Write stable time step explicit (CFL, adhoc)

* Interpolated meshes + temperature field
  No fault, linear elasticity
  Benchmark memory use and speed

  Incompressibility, temperature/heat


* Testing
  + Need full-scale test with variation in physical properties
    within a material.

* Add output of initial fields (initial stress and initial strain).

* Combined kinematic and dynamic fault implementation

  FaultCohesiveKinDyn

    Add EqKinSrcs to FaultCohesiveDyn

    Use kinematic slip unless fault constitutive model suggests larger slip

* utilities
  + pylith_eqsummary
    Calculate eq statistics for given slip model (VTK output).
    Ability to get shear modulus on both sides of the fault (use fault normal).

* Lumped solver [Brad]
  + Need to finish unit tests

  AbsorbingDampers
    integrateResidualLumped()
  FaultCohesiveDyn
    adjustSolnLumped()

  Make fault nucleation (initial tractions) modular (allow space/time
  variation).

* Time step based on state variables

  TimeStepStrainRate object
    strainRateTarget
    strainRateTolerance
    maxDt
    updateInterval

    if (fabs(1.0 - strainRate / strainRateTarget) < tolerance) {
      assert(strainRate != 0.0);
      dtNew = dtOld * strainRateTolerance / strainRate;
      if (dtNew > maxDt)
        dtNew = maxDt;
    } // if

  ElasticMaterial
    strain rate not stored for purely elastic materials

    storeStrainRate()
      set flag to store strain rate
    maxStrainRate()
      compute total strain (if nec)
      compute strain rate, get maximum
    
----------------------------------------------------------------------
CLEANUP
----------------------------------------------------------------------

Brad

  Memory model
    C++ Objects with fields
        DirichletBoundary (_outputFields)
        PointForce (BoundaryConditionPoints::_parameters) ACCESSOR DONE
        AbsorbingDampers (_parameters)
        Neumann (_parameters)
        Quadrature (_geometryFields) [should be NULL]
        OutputManager (_fields)
        CellFilterAvg (_fieldAvg)
        VertexFilterVecNorm (_fieldVecNorm)
 
  full-scale testing
    2d/quad4
      axialtract
      sheartract
      dislocation2
      fourcells_twofaults (1 proc, 2 procs)
    2d/tri3
      dislocation
      dislocation2
  cleanup

    Switch Components to PetscComponents.
      Add _cleanup() to components to deallocate local data structures.
      Add cleanup() to non-components to deallocate local data structures.

      Need to call parent deallocate() but not objects deallocate.
      bc C++, SWIG
      faults C++, SWIG
      feassemble C++, SWIG
      materials C++, SWIG
      meshio C++, SWIG
      problems C++, SWIG
      topology C++, SWIG

  * write cells as ints in HDF5


2. Analytic BC for reverse-slip benchmark [Charles or Brad]
    a. Create BC for CUBIT mesh.
    b. Create BC for LaGriT mesh.
    c. Run benchmarks.
    d. Generate analytic solutions.
    e. Tabulate results.

3. Add missing unit tests

    pytests
      test_configure

    libtests/topology/TestMesh::testNondimensionalize()

    libtests/topology/Field add constraints to field in unit tests
      copy
      +=

    pytests.meshio.TestOutputSoln
    pytests.meshio.TestOutputDirichlet
    pytests.meshio.TestOutputFaultKin
    pytests.meshio.TestOutputMatElastic
    pytests.meshio.TestOutputNeumann

    libtests/materials
      Cleanup dbToStateVars for Maxwell models (use ids don't just copy)
      Cleanup testUpdateStateVars for Maxwell models

    libtests/bc/TestDirichletBoundary::testVertexField()
    libtests/bc/TestDirichletBoundary::testBoundaryMesh()

    pytests/bc/TestDirichletBoundary
    pytests/bc/TestNeumann (output)

    libtests/feassemble/ElasticityExplict
      testVerifyConfiguration()
      testCellField()
    libtests/feassemble/ElasticityImplict
      testVerifyConfiguration()
      testCellField()
    libtests/materials/Material
      propertyField()
      stateVarField()

    libtests/meshio/CellFilter for submesh

    MeshIO::normalizer()
    Material::normalizer()
    Constraint::normalizer()
    Integrator::normalizer()
    DataWriter::normalizer()

    Mesh::coneSize()
    Mesh::numVertices()
    Mesh::numCells()
    TimeDependentPoints::parameterFields()
    Material::propertiesField()
    Material::stateVarsField()

    MeshOps::numMaterialCells()

    PetscApplication.compilePerformanceLog()
    PetscComponent.compilePerformanceLog()
    Material.ncells
    MemoryLogger.logMesh()
    MemoryLogger.logMaterial()

    libtests/faults/FaultCohesiveKin.cc
      Nontrivial dispIncr(t->t+dt) in integrateResidual

4. Tidy up

  Replace memcpy() calls with loops.

  Cleanup logging. Constraints and Integrators should log at the C++
  level using the C++ EventLogger. Add finer grain logging at C++
  level as in ElasticityImplicit.

  Update journaling.

  Eliminate use of Inventory class.

  Switch Components to PetscComponents.
    Add _cleanup() to components to deallocate local data structures.
    Add cleanup() to non-components to deallocate local data structures.

  Create createModuleObj() methods to Python objects as standard way
  of creating handle to C++ object (not necessary in abstract base
  classes).

  Add check before calling newSection() when want to enforce at
  least 1 value.

  Cleanup SlipTimeFn tests (refactor test/initialize stuff)


----------------------------------------------------------------------
RELEASE 1.5
----------------------------------------------------------------------

3. 2-D Plane strain Generalized Maxwell viscoelastic rheology [Charles]

4. 2-D Power-law rheology [Charles]
   2D viscoelastic models for plane strain

5. Initial stress, strain, state variables for inelastic models

  Use switch to do elastic prestep so that main time loop is all
  anelastic in the most general case. Want to generate an error if
  both initial state variables are given and using an elastic prestep.

======================================================================
KNOWN DEFICIENCIES
======================================================================

* Dirichlet BC and fault BC

  Can't use block Jacobi preconditioner when Dirichlet BC overlap with
  fault BC's, because we end up with a DOF associated with a Lagrange
  multiplier that is "free". Not sure if this is okay, when the fault
  is at an angle to the boundary.

    Might be able to fix this problem by examining constraints
    relative to orientation and if orientation coincides with
    preexisting constraint, then constrain Lagrange multiplier DOF.

  Need better error trapping when using LineParser. State of
  ifstream is insufficient. Need state of istringstream buffer, but it
  is often !good() at eof(). Test of !good() and !eof()?

* ZeroDispDB

  The default BC is ZeroDispDB which hardwires the values in a UniformDB
  to 0. No error message is generated if the user sets the values or
  data properties and they are overwritten by the hardwired values. A
  possible solution is for ZeroDispDB to use a C++ UniformDB but not
  inherit from the Python UniformDB.

* Fault orientatin in 1-D mesh

  How do we determine the orientation for a fault in a 1-D mesh? We
  assume normaldir is +1.0, but cohesive cells could be created so
  that the fault has a normaldir of -1.0. If the normaldir is -1.0,
  then we need to flip the orientation field to get the correct
  sense of slip.



======================================================================
MISC PRIORITIES (Brad)
======================================================================

4. OutputManager
   a. VertexFilterChangeCS
      OutputFilter for writing vertex coordinates in another 
      coordinate system. Need test for whether two coordinate systems 
      are the same.

======================================================================
PLANNED RELEASES
======================================================================

----------------------------------------------------------------------
Release 1.7
----------------------------------------------------------------------

  1. Damping for Q
    Generalized Maxwell approach for attenuation

  2. 2-D materials
    + DruckerPragerPlaneStrain (Drucker-Prager plane strain)
    + PowerLawPlaneStrain (power law plane strain )

  3. Scalable mesh distribution

----------------------------------------------------------------------
Release 2.0
----------------------------------------------------------------------

  1. Restart / checkpointing
    Checkpointing
    Spin up
    Saving quasi-static information is probably more important

  2. Green's functions

  3. Coupling of quasi-static and dynamic simulations

  1. Higher order cells

     Nonisoparametric cells

       C++ unit tests for CellGeometry refPtsToGlobal() and jacobian()
       Update quadrature to use CellGeometry refPtsToGlobal() and
       jacobian() Remove CellGeometry jacobian(double_array)

  2. Output data at arbitrary point locations

     Interpolate solution to desired location
     Solution field (time history)

----------------------------------------------------------------------
Low-priority items (release unknown)
----------------------------------------------------------------------

  6. FaultCohesiveTract (dikes)

  4. Improved support for spherical geometry in user-interface

----------------------------------------------------------------------
LONG TERM WISH LIST
----------------------------------------------------------------------

Student
      Create a spatial database for the PREM model

  5. Use shared pointers for objects where both Python and C++ hold pointers.

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

2. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  This already works. Our code is written in terms of numBasisFuncs, not
  vertices. Therefore, if we just use the P2 element from FIAT, our only
  problem is to correctly allocate the section (I think). To do this, we
  add the appropriate setFiberDimension() call. FIAT has this information,
  we just are not using it right now.

3. Uniform refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2- 2 or 4)
  Outputs:
    * PETSc Mesh (refined)

  This already works. You just call

  double maxVolume   = 0.01;
  bool   interpolate = false;
  ALE::Obj<ALE::Mesh> newMesh = ALE::Generator::refineMesh(oldMesh, maxVolume, interpolate);

  There is another version that takes an array of maxVolumes, one for each cell in oldMesh.

6. Coarsening for PyLith meshes

7. Time fixes

  Not used a. Remove extra time in uninterpolated restrict(). May need special method for P1.

  Done c. getStateVars() is way too expensive. 

  Not used d. Same as a) for update

8. Memory fixes

  Done a. Share memory in precomputation sections

11. For Schur complement directly for mass matrix and Lagrange multiplier problem
