======================================================================
MAIN PRIORITIES (Brad)
======================================================================

Cleanup

  Add check at beginning of simulation to make sure cell dimension
  matches space dimension. We don't have enough information to
  determine the fault orientation information for a cell in a higher
  dimension coordinate space. We also haven't implemented the
  elasticity stuff for lower dimension cells in a higher
  dimensions. Since Sieve can handle lower order meshes in higher
  dimensions, we probably want to allow it in MeshIO, just not in the
  simulation where we don't support it.

1. Switch to more uniform implementation of integrators.

  Formulation HASA FieldsManager (solnfields)

  Integrators have
    integrateResidual(residual, solnfields, mesh, timeId)
    integrateJacobian(jacobian, solnfields, mesh, timeId)

  timeId = {'t+dt', 't', 't-dt'}

2. Finish implementing ExplicitElasticity and Explicit
   a. Replace integrateConstant() with integrateResidual()

     {f}-[A]{u}, {u} is "guess" (zero for explicit)

   a. Double check loops for integrateResidual() and integrateJacobian()
   b. Create unit test (construction of residual term and Jacobian)

   c. Add unit test for IntegratorElasticity::calcTotalStrain

2a. Cleanup integrators and boundary conditions.

   a. Categorize into "integrators" and "constraints"
   b. Add feature to materials and integrators wherein they indicate
      if the Jacobian needs to be reformed at the current time step.

3. Add dualBasis to Quadrature.
   a. Python
     ReferenceCell
     FIATSimplex
     Quadrature()
   b. C++
     Quadrature
   c. C++ unit tests
   d. Python unit tests

4. Implement faults for kinematic source
   a. Creation of cohesive cells
     i. Add tests for interpolated meshes.
        Double check consistency in ordering of vertices (positive/negative).

   b. Implement integrator for faults

     i. FaultCohesive
       (2) Python unit tests
	 constructor
         initialize()

     ii. BruneSlipFn
       (1) C++ unit tests
         initialize()
         slip()
       (2) Python unit tests
         constructor
         initialize()

     iii. EqKinSrc
       (1) C++ unit tests
         constructor
         clone()
         slipfn()
         initialize()
         slip()
       (2) Python unit tests
         constructor
         initialize()

     iv. FaultCohesiveKin
       (1) C++ unit tests
         constructor
         clone()
         eqsrc()
         initialize()
         integrateResidual()
         integrateJacobian()
         setField()
         _useLagrangeConstraint()
       (2) Python unit tests
         constructor
         initialize()

5. Implement absorbing boundary conditions

6. Create suite of simple full test cases

======================================================================
SECONDARY PRIORITIES
======================================================================

1. Implement MeshIOHDF5 & HDF5 (helper class)
   a. C++ objects
   b. unit tests at C++ level
   c. Python object (MeshIOHDF5)
   d. bindings
   e. unit tests at Python level

2. Reimplement SolutionIO.

   Follow implementation of MeshIO. SolutionIO implements extracting
   data from Sieve and calls virtual functions to write data.

   a. Reimplement SolutionIOVTK
   b. Implement SolutionIOHDF5

======================================================================
UNRESOLVED ISSUES
======================================================================

0. Basis functions for Lagrange elements (quad4, hex8, plus quadratic cells)
   [Matt]

1. How to get orientation of faces at vertices? [discuss with Matt]

2. Integration of nemesis (pylithic.py as mpi/python application) [Leif?]

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

1. Create PETSc mesh with associated boundary condition meshes.

  In general we can only rely on mesh generators to provide vertices,
  cells, attributes for vertices and cells (i.e., one value for each
  vertex or cell), and groups of vertices and cells. As a result,
  boundary conditions would be associated with groups of
  vertices. This is nonunique if we require users to not allow
  multiple surfaces be associated with a single group of vertices. In
  other words, there is a unique set of faces for a group of
  vertices. For our boundary conditions we will want the N-1 dimension
  (where the mesh is N dimensions) representation of a subset of the
  mesh (i.e., 2-D mesh of fault surface).

  Inputs:
    * PETSc mesh
    * Group of vertices
  Outputs:
    * PETSc mesh with bc mesh

  Note: Above would be repeated for each group of vertices.

2. Create cohesive cells.

  Inputs:
    * PETSc mesh
    * Surface meshes defining faults
  Output:
    * PETSc mesh with cohesive cells.

  Note: Not sure whether this would be done with global or distributed mesh.

3. Distribute mesh/bc in scalable manner. 

  Inputs:
    * PETSc Mesh (with bc) (global on each processor)
    * number of processors
  Outputs:
    * PETSc Mesh on each processor (restricted to processor)

  [DONE]

4. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2?)
  Outputs:
    * PETSc Mesh (refined)

5. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  Note: I think this would give us incredible flexibility in selecting
  the appropriate discretization for a problem. For example, I think
  it would allow us to use spectral elements.

6. Trial run with quadratic elements

7. Trial run with fully interpolated mesh

======================================================================
QUESTIONS FOR LEIF
======================================================================

