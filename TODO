======================================================================
CURRENT ISSUES
======================================================================

Release 1.0.2

  1. Fix memory use on proc 0 when partitioning.

  2. Fix problems with buildbot on darwin.

  3. Add check to make sure every material in mesh has a material model.

    Add check for overlapping of material ids for bulk and cohesive
    cells.

Release 1.1

  1. Finish AbsorbingDampers BC.
    Python
    module
    Python unit tests

  2. Finish Neumann BC.

  3. Finish velocity Dirichlet BC.

  4. Generalized Maxwell viscoelastic model

  5. Move PETSc logging out of feassemble module.

  6. Reimplement SolutionIO.
     a. Reimplement SolutionIOVTK
     b. Implement SolutionIOHDF5

     General Ideas

       Need to be able to append fields.

       It should be possible to use PETSc viewers, but we will want to
       setup the viewers in implementation classes and then call the
       view in the parent class?

       Want open(), writeTopology(), appendVertexField(),
       appendCellField(), close() paradigm.

     Use Cases

       Want to write topology + vertex and/or cell fields

       For visualization, we want cell fields that are averaged over
       the cell's quadrature points. There may be some cases
       (benchmarking), in which we want the cell fields at each
       quadrature point.

       VTK files

         One per time step, multiple vertex and/or cell fields

       HDF5 files

         One per topology (volume, surface, etc)

         Would prefer to include multiple materials

         Datasets contain entire time histories (makes it possible to
         slice along time or space)

       Volume information

         Solution field (time histories)

         Distribution information (proc of each cell)

         State variable information for each cell (different info for
         each material)

           Material parameters (diagnostic)

           State variable values (time histories)

       Lower dimension information (surface/line mesh specified by set
       of vertices)

         Solution field (time histories)

       Kinematic fault rupture

         Slip and change in tractions (time histories)

         Orientation, final slip, slip time (disgnostic)

       Spontaneous (dynamic) fault rupture

         Slip and change in tractions (time histories)

         Fault constitutive values (time histories)

         Orientation , Fault constitutive parameters (diagnostic)

       Point locations (arbitrary location such as instrument site)

         Interpolate solution to desired location

         Solution field (time history)

General

  1. Need to add explanation of output and output parameters to
  manual (especially fault information).

  2. Add dependency diagram to manual.

  3. Experiment with different preconditioners and tabulate results

======================================================================
KNOWN DEFICIENCIES
======================================================================

  Can't use block Jacobi preconditioner when Dirichlet BC overlap with
  fault BC's, because we end up with a DOF associated with a Lagrange
  multiplier that is "free". Not sure if this is okay, when the fault
  is at an angle to the boundary.

    Might be able to fix this problem by examining constraints
    relative to orientation and if orientation coincides with
    preexisting constraint, then constrain Lagrange multiplier DOF.

  Need better error trapping when using LineParser. State of
  ifstream is insufficient. Need state of istringstream buffer, but it
  is often !good() at eof(). Test of !good() and !eof()?

======================================================================
MAIN PRIORITIES (Brad)
======================================================================

0. Create 6x6x4 meshes for examples.
  CUBIT
    Add GUI instructions in journal files.

1. Create meshes for benchmarks

  reverse
    tet (LaGriT)
    hex (CUBIT)

2. Additional unit tests

   a. ElasticityExplicit and ElasticityImplicit
      i. multiple materials
      ii. partially constrained DOF

======================================================================
SECONDARY PRIORITIES
======================================================================

Want to take advantage of symmetry and block structure of Jacobian
matrix when possible.

Additional unit tests
  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]

1. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

======================================================================
PLANNED RELEASES
======================================================================

Other (unknown release):
  higher order cells from linear cells
  initial stress field (from spatial db)

----------------------------------------------------------------------
PyLith 1.1
----------------------------------------------------------------------
Nonlinear solvers
HDF5 output
  volume (solution field)
  ground surface (or other surfaces) (solution field)
  points (solution field)
  cells (state variables)
Absorbing boundary conditions
Traction boundary conditions
Generalized Maxwell viscoelastic model
Velocity boundary conditions
Gravity (spatial db)

----------------------------------------------------------------------
PyLith 1.2
----------------------------------------------------------------------
Fault friction interface conditions
Fault constitutive models
  Linear slip-weakening
  Rate- and state-friction
  Uniform friction
  Slip- and rate-weakening friction model

----------------------------------------------------------------------
PyLith 1.3
----------------------------------------------------------------------
Green's functions

----------------------------------------------------------------------
PyLith 1.4
----------------------------------------------------------------------
Coupling
Adaptive time stepping

----------------------------------------------------------------------
PyLith 1.5
----------------------------------------------------------------------
Large deformation
Improved support for spherical geometry in user-interface
Power-law viscoelastic material

----------------------------------------------------------------------
PyLith 1.6
----------------------------------------------------------------------
Adaptive mesh refinement

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

1. Boundary mesh

  This works and there is a unit test.

2. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  This already works. Our code is written in terms of numBasisFuncs, not
  vertices. Therefore, if we just use the P2 element from FIAT, our only
  problem is to correctly allocate the section (I think). To do this, we
  add the appropriate setFiberDimension() call. FIAT has this information,
  we just are not using it right now.

3. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2- 2 or 4)
  Outputs:
    * PETSc Mesh (refined)

  This already works. You just call

  double maxVolume   = 0.01;
  bool   interpolate = false;
  ALE::Obj<ALE::Mesh> newMesh = ALE::Generator::refineMesh(oldMesh, maxVolume, interpolate);

  There is another version that takes an array of maxVolumes, one fo each cell in oldMesh.

4. Check in nonlinear solver

5. Throw out cohesive midnodes from censored depth (not easy since they are mixed in with new vertices, maybe change numbering)

6. Coarsening for PyLith meshes

7. Time fixes

  Not used a. Remove extra time in uninterpolated restrict(). May need special method for P1.

  Done b. Precompute element geometry

  Done c. getStateVars() is way to expensive. It looks like _getParameters() allocates an int_array. Try just using _numParamValues.

  Not used d. Same as a) for update

  Done e. Put in flop counting for IR

8. Memory fixes

  Done a. Share memory in precomputation sections

9. Fixup FASTER improvements

10. Move events to Python (make wrappers for events)

======================================================================
QUESTIONS FOR LEIF
======================================================================

