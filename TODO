======================================================================
KNOWN DEFICIENCIES
======================================================================

  Can't use block Jacobi preconditioner when Dirichlet BC overlap with
  fault BC's, because we end up with a DOF associated with a Lagrange
  multiplier that is "free". Not sure if this is okay, when the fault
  is at an angle to the boundary.

    Might be able to fix this problem by examining constraints
    relative to orientation and if orientation coincides with
    preexisting constraint, then constrain Lagrange multiplier DOF.

  Need better error trapping when using LineParser. State of
  ifstream is insufficient. Need state of istringstream buffer, but it
  is often !good() at eof(). Test of !good() and !eof()?

======================================================================
CURRENT ISSUES
======================================================================

Release 1.1

  1. Fix calcTractionsChange.

  2. Check performance of current distribution.

  3. Add more error checking.

     a. Add check to make sure every material in mesh has a material model.

     b. When importing mesh, add check to make sure all cells have same
        number of vertices (especially CUBIT).

     c. Add check to make sure that label in BC, faults, and output
     subset actually exists in mesh (verifyConfiguration()).

  Benchmarks

    1. Strike-slip benchmark.
      c. Rerun benchmarks.
      d. Tabulate results.
      e. Test scaling (1,2,4,8 processors) for 500m hex8 case

    2. Reverse-slip benchmark.
      a. Create BC for CUBIT mesh.
      b. Create LaGriT mesh (based on old LaGriT script).
      c. Create BC for LaGriT mesh.
      d. Run benchmarks.
      e. Generate analytic solutions.
      f. Tabulate results.

  Examples

    1. Test and update settings.
      a. Update output settings (materials, faults, solution).
         twoquad4-geoproj

      b. Remove twoquad4-tractions (have twoquad4/axialtract.cfg)
        If we want these as tests, move them to tests.

    2. Add some simple kinematic rupture examples.
      a. 2-D bar (tri3, quad4)
      b. 3-D bar (tet4, hex8)
      c. simple strike-slip propagating rupture (500m resolution)

    3. CUBIT (Brad)
       Add GUI instructions in journal files for examples/3d/hex8.

  Manual

    1. Need to add explanation of output and output parameters
       (especially fault information).

       Fault information is in fault coordinate system. Add example of
       how to convert it to global coordinates using orientation
       information.

    2. 3 kinds of spatial databases
         UniformDB
         SimpleDB
         SCECCVMHDB

    2. Add dependency diagram. (Brad)

    3. Add benchmarks.

    4. Update cover figure with current result. (Brad)

    5. Remove discussion of containers.
       Use facility array. Include defaults for items.

    6. DirichletPoints/DirichletBoundary
       FixedDOFDB (special case of UniformDB).

    7. Add twotet4-geoproj to tutorials.

    8. Neumann BC

    9. Add note that groups for DirichletBoundary, Neumann,
       AbsorbingDampers, and Fault must be associated with
       simply-connected surfaces.

    10. Add list of concepts at the beginning of each tutorial.

----------------------------------------------------------------------
Release 1.2

  1. Green's functions

  2. Nonisoparametric cells

     C++ unit tests for CellGeometry refPtsToGlobal() and jacobian()
     Update quadrature to use CellGeometry refPtsToGlobal() and jacobian()
     Remove CellGeometry jacobian(double_array)

     Dirichlet and fault constraints?

  3. Multiple earthquake sources
     Add time of rupture to KinEqSrc
     Time within rupture is relative to time of rupture
     Loop over eq sources, if time is greater than time of rupture, use it
     Would allow Savage-Prescott benchmark.

  4. Gravity

  5. Output

       HDF5 files

         Would prefer to include multiple materials

         Datasets contain entire time histories (makes it possible to
         slice along time or space)

       Point locations (arbitrary location such as instrument site)

         Interpolate solution to desired location
         Solution field (time history)

----------------------------------------------------------------------
Release 1.3

  1. Dynamic fault interface conditions.

  2. Fault constitutive models

  3. Nonlinear solver  

  4. Replace use of Pyrex/Pyrexembed with SWIG

  5. Additional output

       Spontaneous (dynamic) fault rupture
         Slip and change in tractions (time histories)
         Fault constitutive values (time histories)
         Orientation , Fault constitutive parameters (diagnostic)

======================================================================
MISC PRIORITIES (Brad)
======================================================================

1. Want to take advantage of symmetry and block structure of Jacobian
   matrix when possible.

2. Additional unit tests
  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]

3. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

4. OutputManager
   a. VertexFilterChangeCS
      OutputFilter for writing vertex coordinates in another 
      coordinate system. Need test for whether two coordinate systems 
      are the same.

======================================================================
PLANNED RELEASES
======================================================================

Other (unknown release):
  higher order cells from linear cells
  initial stress field (from spatial db)

----------------------------------------------------------------------
PyLith 1.1
----------------------------------------------------------------------
Output
  volume (solution field)
  ground surface (or other surfaces) (solution field)
  cells (state variables)
Absorbing boundary conditions
Traction boundary conditions
Generalized Maxwell viscoelastic model
Velocity boundary conditions
Gravity (spatial db)

----------------------------------------------------------------------
PyLith 1.2
----------------------------------------------------------------------
Fault friction interface conditions
Fault constitutive models
  Linear slip-weakening
  Rate- and state-friction
  Uniform friction
  Slip- and rate-weakening friction model
Nonlinear solvers

----------------------------------------------------------------------
PyLith 1.3
----------------------------------------------------------------------
Green's functions

----------------------------------------------------------------------
PyLith 1.4
----------------------------------------------------------------------
Coupling
Adaptive time stepping

----------------------------------------------------------------------
PyLith 1.5
----------------------------------------------------------------------
Large deformation
Improved support for spherical geometry in user-interface
Power-law viscoelastic material

----------------------------------------------------------------------
PyLith 1.6
----------------------------------------------------------------------
Adaptive mesh refinement

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

2. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  This already works. Our code is written in terms of numBasisFuncs, not
  vertices. Therefore, if we just use the P2 element from FIAT, our only
  problem is to correctly allocate the section (I think). To do this, we
  add the appropriate setFiberDimension() call. FIAT has this information,
  we just are not using it right now.

3. Uniform refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2- 2 or 4)
  Outputs:
    * PETSc Mesh (refined)

  This already works. You just call

  double maxVolume   = 0.01;
  bool   interpolate = false;
  ALE::Obj<ALE::Mesh> newMesh = ALE::Generator::refineMesh(oldMesh, maxVolume, interpolate);

  There is another version that takes an array of maxVolumes, one for each cell in oldMesh.

5. Throw out cohesive midnodes from censored depth (not easy since they are mixed in with new vertices, maybe change numbering)

   I think you can do this by placing them after cohesive cells

6. Coarsening for PyLith meshes

7. Time fixes

  Not used a. Remove extra time in uninterpolated restrict(). May need special method for P1.

  Done c. getStateVars() is way too expensive. 

  Not used d. Same as a) for update

8. Memory fixes

  Done a. Share memory in precomputation sections

11. For Schur complement directly for mass matrix and Lagrange multiplier problem

======================================================================
QUESTIONS FOR LEIF
======================================================================

