======================================================================
CURRENT ISSUES
======================================================================
  creation of cohesive cells for hex8 meshes
  tests/1d/line3/dislocation.cfg [CHACO]
  tests/3d/tet4/shearelasticstrain.cfg [SIEVE INDEXING AND CONSTRAINTS]
    Note: ordering the Dirichlet BC so that the constrainted DOF are in 
          order is a workaround.

  VTK output
    zero out values at Lagrange constraint vertices
    make 3-component displacements default even for 1-D and 2-D meshes

======================================================================
MAIN PRIORITIES (Brad)
======================================================================

Add catching ALE exceptions in modules.

1. Additional unit tests

  Unit tests with multiple cohesive cells.
    tet4
    hex8

    normal okay with rollover of fault dip?

  b. ElasticityExplicit and ElasticityImplicit
    i. multiple materials
    ii. constrained DOF

examples/templates
  containers
    verify containers work

======================================================================
SECONDARY PRIORITIES
======================================================================

Want to take advantage of symmetry and block structure of Jacobian
matrix when possible.

Additional unit tests
  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]

1. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

2. Implement absorbing boundary conditions

3. Reimplement SolutionIO.

   Follow implementation of MeshIO. SolutionIO implements extracting
   data from Sieve and calls virtual functions to write data.

   a. Reimplement SolutionIOVTK
   b. Implement SolutionIOHDF5

4. Implement MeshIOHDF5 & HDF5 (helper class)
   a. C++ objects
   b. unit tests at C++ level
   c. Python object (MeshIOHDF5)
   d. bindings
   e. unit tests at Python level

======================================================================
UNRESOLVED ISSUES
======================================================================

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

3. Distribute mesh/bc in scalable manner. 

  Inputs:
    * PETSc Mesh (with bc) (global on each processor)
    * number of processors
  Outputs:
    * PETSc Mesh on each processor (restricted to processor)

  [DONE]

4. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2?)
  Outputs:
    * PETSc Mesh (refined)

5. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  Note: I think this would give us incredible flexibility in selecting
  the appropriate discretization for a problem. For example, I think
  it would allow us to use spectral elements.

6. Trial run with quadratic elements

7. Trial run with fully interpolated mesh

======================================================================
QUESTIONS FOR LEIF
======================================================================

