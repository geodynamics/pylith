======================================================================
MAIN PRIORITIES (Brad)
======================================================================

Fix bug related to casting C++ objects in module. This is bad because
we lose what type the abstract base class is.

Unit tests:
  petsc module

0. Create element families for materials.
   a. Move quadrature component from Integrator to Material?
      [Integrator will hold material; user configures quadrature w/material]
   b. In Formulation?, create an integrator for each "material"
     [IN PROGRESS]
   c. C++ Material (1 per element family)
      Holds physical properties
      Initialize involves getting parameters from db
   d. ExplicitElasticity gets density field from material's property manager

1. Finish implementing ExplicitElasticity
   a. C++
   a. Python object
   b. bindings
   c. unit tests at C++ level
   d. unit tests at Python level

  Status: Started on a.

2.  Finish implementing Python Formulation
    (e.g., Explicit) with initialization of solid element families.
   c. Python object
   e. unit tests at Python level

3. Implement unit tests for MeshIO at Python level.
   a. write()/read()
   b. checkVals()

  STATUS: 

    Postponed. Easiest implementation requires semi-messy build
    on top of libtests/meshio classes and initializing/finalizing
    PETSc from Python. May be easier to include in higher-level unit
    test.

======================================================================
SECONDARY PRIORITIES
======================================================================

1. Implement MeshIOHDF5 & HDF5
   a. C++ objects
   b. unit tests at C++ level
   b. Python object (MeshIOHDF5)
   c. bindings
   d. unit tests at Python level

2. Implement MeshIOCubit
   a. C++ objects
   b. unit tests at C++ level
   b. Python object (MeshIOCubit)
   c. bindings
   d. unit tests at Python level

======================================================================
UNRESOLVED ISSUES
======================================================================

1. Integration of nemesis (pylithic.py as mpi/python application) [Leif?]

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

1. Create PETSc mesh with associated boundary condition meshes.

  In general we can only rely on mesh generators to provide vertices,
  cells, attributes for vertices and cells (i.e., one value for each
  vertex or cell), and groups of vertices and cells. As a result,
  boundary conditions would be associated with groups of
  vertices. This is nonunique if we require users to not allow
  multiple surfaces be associated with a single group of vertices. In
  other words, there is a unique set of faces for a group of
  vertices. For our boundary conditions we will want the N-1 dimension
  (where the mesh is N dimensions) representation of a subset of the
  mesh (i.e., 2-D mesh of fault surface).

  Inputs:
    * PETSc mesh
    * Group of vertices
  Outputs:
    * PETSc mesh with bc mesh

  Note: Above would be repeated for each group of vertices.

2. Create cohesive cells.

  Inputs:
    * PETSc mesh
    * Surface meshes defining faults
  Output:
    * PETSc mesh with cohesive cells.

  Note: Not sure whether this would be done with global or distributed mesh.

3. Distribute mesh/bc in scalable manner. 

  Inputs:
    * PETSc Mesh (with bc) (global on each processor)
    * number of processors
  Outputs:
    * PETSc Mesh on each processor (restricted to processor)

  Note: Called from topology.Mesh.py (need Python bindings for Sieve function).

4. Global refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2?)
  Outputs:
    * PETSc Mesh (refined)

5. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  Note: I think this would give us incredible flexibility in selecting
  the appropriate discretization for a problem. For example, I think
  it would allow us to use spectral elements.
