======================================================================
CURRENT ISSUES/PRIORITIES
======================================================================

-1. Fix Tabrez's bug. [Matt]

1. SNES

  Power-law rheology

2. Nondimensionalization

  Add Quadrature::computeGeometry(cell, coordinatesCell)
    do computation on 1 cell
    much less memory than holding all info in Fields
    keep computeGeometruy(mesh, cell) and retrieveGeometry(cell)

  DataWriteVTK needs dimensionalizer

  Done coordinates in output (nondimensional instead of dimensioned)
  create dimensionalized copy (NAME_dimensioned) solution in output
  (nondimensional instead of dimensioned) const slip rate in output
  (slip rate not slip)

  Add ability to use symmetric matrix.

  Ask constraints if a block matrix is okay. If okay and matrix type
  is "unknown" (not set by user), then use "baij" rather than
  "aij". Do this in Python.

3. Full-scale tests (few 1-D, 2-D, and 3-D)

    1-D
      1. axial disp [DONE]
      2. dislocation [DONE]

    2-D
      1. axial/shear (DirichletBC)
      2. axial/shear (DirichletBC, parallel)
      3. axial traction (Neumann, DirichletBC)
      4. single fault (static)
      5. single fault (quasi-static w/multiple ruptures)
      6. single fault (dynamic)
      7. two fault (static)
      8. two fault (static, parallel)

    3-D
      1. axial/shear (DirichletBC)
      2. axial/shear (DirichletBC, parallel)
      3. single fault (static)
      4. single fault (Savage/Prescott like)
      5. single fault (dynamic)
      6. two fault (static)
      7. two fault (static, parallel)
      8. gravity w/initial stress and strain 


4. Add missing unit tests

    libtests/topology/Field add constraints to field in unit tests
      copy
      +=

    pytests.meshio.TestOutputSoln
    pytests.meshio.TestOutputDirichlet
    pytests.meshio.TestOutputFaultKin
    pytests.meshio.TestOutputMatElastic
    pytests.meshio.TestOutputNeumann

    add test_factory() methods to Python unit tests

    pytests
      test_configure

    libtests/materials
      Cleanup dbToStateVars for Maxwell models (use ids don't just copy)
      Cleanup testUpdateStateVars for Maxwell models

    libtests/bc/TestDirichletBoundary::testVertexField()
    libtests/bc/TestDirichletBoundary::testBoundaryMesh()

    pytests/bc/TestDirichletBoundary
    pytests/bc/TestNeumann (output)

    libtests/feassemble/ElasticityExplict
      testVerifyConfiguration()
      testCellField()
    libtests/feassemble/ElasticityImplict
      testVerifyConfiguration()
      testCellField()
    libtests/materials/Material
      propertyField()
      stateVarField()

    Need unit tests
      MeshIO::normalizer()
      Material::normalizer()
      Constraint::normalizer()
      Integrator::normalizer()
      DataWriter::normalizer()

      Mesh::coneSize()
      Mesh::numVertices()
      Mesh::numCells()

      MeshOps::numMaterialCells()

      PetscApplication.compilePerformanceLog()
      PetscComponent.compilePerformanceLog()
      Material.ncells
      MemoryLogger.logMesh()
      MemoryLogger.logMaterial()

5. Tidy up

    How do we determine the orientation for a fault in a 1-D mesh? We
    assume normaldir is +1.0, but cohesive cells could be created so
    that the fault has a normaldir of -1.0. If the normaldir is -1.0,
    then we need to flip the orientation field to get the correct
    sense of slip.

    Add simple stableTimeStep() for elastic materials.

    Cleanup logging. Constraints and Integrators should log at the C++
    level using the C++ EventLogger. Add finer grain logging at C++
    level as in ElasticityImplicit.

    Update journaling.

    Add
      throw std::logic_error(message);
    after assert(0) to insure error is trapped.

    Use Fields object to hold Field

    Eliminate use of Inventory class.

    Switch Components to PetscComponents.
      Add _cleanup() to components to deallocate local data structures.
      Add cleanup() to non-components to deallocate local data structures.

    Create createModuleObj() methods to Python objects as standard way
    of creating handle to C++ object (not necessary in abstract base
    classes).

    Add check before calling newSection() when want to enforce at
    least 1 value.

  libsrc/materials
    Generalized Maxwell materials

  DirichletBC (Python) - rate == None -> dbRate == 0
  DirichletBoundary (Python) - rate == None -> dbRate == 0

  Cleanup SlipTimeFn tests (refactor test/initialize stuff)

6. Memory model [Matt]
   playpen/memcheck/*

   Must add nested stages so that logging totals are correct

7. 2-D Plane strain Maxwell viscoelastic rheology [Charles]

8. 2-D Plane strain Generalized Maxwell viscoelastic rheology [Charles]

9. 2-D Power-law rheology [Charles]
   2D viscoelastic models for plane strain

10. Initial stress, strain, state variables for inelastic models [Charles]

11. Savage-Presscott benchmark [Charles]

12. Analytic BC for reverse-slip benchmark [Charles or Brad]
    a. Create BC for CUBIT mesh.
    b. Create BC for LaGriT mesh.
    c. Run benchmarks.
    d. Generate analytic solutions.
    e. Tabulate results.

13. Update manual for version 1.4 [Brad and Charles]

  Installation using source tarball should not require SWIG, Pyrex, or
  Pyrexembed [need to test]. Should include .i files in tarball for
  reference.

  Other files
    INSTALL, README, DEPENDENCIES, AUTHORS, ChangeLog
    

  * Reduce memory use with ordering elements by material

  * Nondimensionalization

  * Material
    * initial stress, strain, and state variables
    * Cleanup notation and discussion of inelastic materials

-- Release (v1.4) --

Modularize output? [Matt]
  "field_dimensioned" is prefered to "field"

Fault friction

Uniform refinement (debug, check, all cell types)

Cuthill-McKee ordering of vertices

======================================================================
KNOWN DEFICIENCIES
======================================================================

* Dirichlet BC and fault BC

  Can't use block Jacobi preconditioner when Dirichlet BC overlap with
  fault BC's, because we end up with a DOF associated with a Lagrange
  multiplier that is "free". Not sure if this is okay, when the fault
  is at an angle to the boundary.

    Might be able to fix this problem by examining constraints
    relative to orientation and if orientation coincides with
    preexisting constraint, then constrain Lagrange multiplier DOF.

  Need better error trapping when using LineParser. State of
  ifstream is insufficient. Need state of istringstream buffer, but it
  is often !good() at eof(). Test of !good() and !eof()?

* FixedDOFDB

  The default BC is FixedDOF which hardwires the values in a UniformDB
  to 0. No error message is generated if the user sets the values or
  data properties and they are overwritten by the hardwired values. A
  possible solution is for FixedDOF to use a C++ UniformDB but not
  inherit from the Python UniformDB.

======================================================================
MISC PRIORITIES (Brad)
======================================================================

1. Want to take advantage of symmetry and block structure of Jacobian
   matrix when possible.

2. Additional unit tests
  a. FaultCohesive
    i. Add checking of faultMesh [not currently used]

3. Allow use of all elasticity constants (9 for 2-D, 36 for 3-D).
   a. Materials C++ code
   b. Integrator C++ code
   b. Material C++ unit tests

4. OutputManager
   a. VertexFilterChangeCS
      OutputFilter for writing vertex coordinates in another 
      coordinate system. Need test for whether two coordinate systems 
      are the same.

======================================================================
PLANNED RELEASES
======================================================================

----------------------------------------------------------------------
Release 1.4
----------------------------------------------------------------------

  1. Interface w/PETSc nonlinear solvers

  3. Nonlinear bulk rheologies

     Power-law viscoelastic material
  4. Fault constitutive models

     Linear slip-weakening
     Rate- and state-friction
     Uniform friction
     Slip- and rate-weakening friction model

       Spontaneous (dynamic) fault rupture output
         Slip and change in tractions (time histories)
         Fault constitutive values (time histories)
         Orientation , Fault constitutive parameters (diagnostic)

  5. Uniform global refinement

  6. Improved PC for kinematic faults

  Improved support for spherical geometry in user-interface

----------------------------------------------------------------------
Release 1.5
----------------------------------------------------------------------

  1. Time dependent BCs

  2. Large deformations

  3. Finite strain

  4. Higher order cells

     Nonisoparametric cells

       C++ unit tests for CellGeometry refPtsToGlobal() and jacobian()
       Update quadrature to use CellGeometry refPtsToGlobal() and
       jacobian() Remove CellGeometry jacobian(double_array)

----------------------------------------------------------------------
Release 1.6
----------------------------------------------------------------------

  1. Green's functions

----------------------------------------------------------------------
Release 1.7
----------------------------------------------------------------------

  1. Coupling of quasi-static and dynamic simulations

  2. Restart / checkpointing

  3. Uniform global refinement.

----------------------------------------------------------------------
LONG TERM WISH LIST
----------------------------------------------------------------------

  4. HDF5 output

       HDF5 files

         Would prefer to include multiple materials

         Datasets contain entire time histories (makes it possible to
         slice along time or space)

       Point locations (arbitrary location such as instrument site)

         Interpolate solution to desired location
         Solution field (time history)

  5. Use shared pointers for objects where both Python and C++ hold pointers.

======================================================================
THINGS WE NEED SIEVE TO DO (Matt)
======================================================================

2. Construct mesh with higher order cells from mesh with lower order cells.

  Many mesh generators do not know how to construct higher order
  elements, so we will need a general utility for doing this.

  Inputs:
    * PETSc Mesh
    * some sort of map (Python object) defining how to construct
      higher order reference cell from lower order reference cell.
  Output:
    * PETSc Mesh

  This already works. Our code is written in terms of numBasisFuncs, not
  vertices. Therefore, if we just use the P2 element from FIAT, our only
  problem is to correctly allocate the section (I think). To do this, we
  add the appropriate setFiberDimension() call. FIAT has this information,
  we just are not using it right now.

3. Uniform refinement of mesh.

  Inputs:
    * PETSc Mesh (original)
    * refinement factor (limited to factor of 2- 2 or 4)
  Outputs:
    * PETSc Mesh (refined)

  This already works. You just call

  double maxVolume   = 0.01;
  bool   interpolate = false;
  ALE::Obj<ALE::Mesh> newMesh = ALE::Generator::refineMesh(oldMesh, maxVolume, interpolate);

  There is another version that takes an array of maxVolumes, one for each cell in oldMesh.

6. Coarsening for PyLith meshes

7. Time fixes

  Not used a. Remove extra time in uninterpolated restrict(). May need special method for P1.

  Done c. getStateVars() is way too expensive. 

  Not used d. Same as a) for update

8. Memory fixes

  Done a. Share memory in precomputation sections

11. For Schur complement directly for mass matrix and Lagrange multiplier problem
