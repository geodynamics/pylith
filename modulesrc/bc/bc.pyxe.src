# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/bc/BoundaryCondition.hh"
#include "pylith/feassemble/Constraint.hh"
#include "pylith/feassemble/Integrator.hh"
#include "pylith/bc/AbsorbingDampers.hh"
#include "pylith/bc/DirichletPoints.hh"
#include "pylith/bc/DirichletBoundary.hh"
#include "pylith/bc/Neumann.hh"

#include "pylith/utils/array.hh"

#include <assert.h>
#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

# ----------------------------------------------------------------------
cdef void BoundaryCondition_destructor(void* obj):
  """
  Destroy BoundaryCondition object.
  """
  # create shim for destructor
  #embed{ void BoundaryCondition_destructor_cpp(void* objVptr)
  pylith::bc::BoundaryCondition* pM = (pylith::bc::BoundaryCondition*) objVptr;
  delete pM;
  #}embed
  BoundaryCondition_destructor_cpp(obj)
  return


cdef class BoundaryCondition:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_bc_BoundaryCondition"
    return


  def verifyConfiguration(self, mesh):
    """
    Verify compatibility of configuration settings.
    """
    # create shim for method 'verifyConfiguration'
    #embed{ void BoundaryCondition_verifyConfiguration(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::BoundaryCondition*) objVptr)->verifyConfiguration(*mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    BoundaryCondition_verifyConfiguration(self.thisptr, ptrFromHandle(mesh))
    return


  def initialize(self, mesh, cs, upDir):
    """
    Initialize boundary condition.
    """
    # create shim for method 'initialize'
    #embed{ void BoundaryCondition_initialize(void* objVptr, void* meshVptr, void* csVptr, double* upDirPtr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      pylith::double_array upDir(3);
      upDir[0] = upDirPtr[0];
      upDir[1] = upDirPtr[1];
      upDir[2] = upDirPtr[2];
      ((pylith::bc::BoundaryCondition*) objVptr)->initialize(*mesh, cs, upDir);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::geocoords::CoordSys'."
    if 3 != len(upDir):
      raise TypeError, \
            "Argument 'upDir' must be a 3 vector (list)."
    cdef double upDirCpp[3]
    upDirCpp[0] = upDir[0]
    upDirCpp[1] = upDir[1]
    upDirCpp[2] = upDir[2]
    BoundaryCondition_initialize(self.thisptr, ptrFromHandle(mesh), ptrFromHandle(cs), upDirCpp)
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, BoundaryCondition_destructor)


  property label:
    def __set__(self, value):
      """
      Set label of material.
      """
      # create shim for method 'label'
      #embed{ void BoundaryCondition_label_set(void* objVptr, char* value)
      try {
        assert(0 != objVptr);
        ((pylith::bc::BoundaryCondition*) objVptr)->label(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      BoundaryCondition_label_set(self.thisptr, value)


  property db:
    def __set__(self, value):
      """
      Set spatial database for parameters.
      """
      # create shim for method 'db'
      #embed{ void BoundaryCondition_db_set(void* objVptr, void* dbVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dbVptr);
        spatialdata::spatialdb::SpatialDB* db =
          (spatialdata::spatialdb::SpatialDB*) dbVptr;
        ((pylith::bc::BoundaryCondition*) objVptr)->db(db);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_spatialdb_SpatialDB":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::spatialdb::SpatialDB'."
      BoundaryCondition_db_set(self.thisptr, ptrFromHandle(value))


# ----------------------------------------------------------------------
cdef class DirichletPoints(BoundaryCondition):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* DirichletPoints_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::bc::DirichletPoints);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    BoundaryCondition.__init__(self)
    self.thisptr = DirichletPoints_constructor()
    self.handle = self._createHandle()
    return


  property referenceTime:
    def __set__(self, value):
      """
      Set reference time for rate of change of values.
      """
      # create shim for method 'referenceTime'
      #embed{ void DirichletPoints_referenceTime_set(void* objVptr, double value)
      try {
        assert(0 != objVptr);
        ((pylith::bc::DirichletPoints*) objVptr)->referenceTime(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      DirichletPoints_referenceTime_set(self.thisptr, value)


  property dbRate:
    def __set__(self, value):
      """
      Set spatial database for parameters of rate of change of values.
      """
      # create shim for method 'dbRate'
      #embed{ void DirichletPoints_dbRate_set(void* objVptr, void* dbVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dbVptr);
        spatialdata::spatialdb::SpatialDB* db =
          (spatialdata::spatialdb::SpatialDB*) dbVptr;
        ((pylith::bc::DirichletPoints*) objVptr)->dbRate(db);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_spatialdb_SpatialDB":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::spatialdb::SpatialDB'."
      DirichletPoints_dbRate_set(self.thisptr, ptrFromHandle(value))


  property fixedDOF:
    def __set__(self, value):
      """
      Set fixed DOF.
      """
      # create shim for method 'fixedDOF'
      #embed{ void DirichletPoints_fixedDOF_set(void* objVptr, int* dofVptr, int numFixedDOF)
      try {
        assert(0 != objVptr);
        assert(0 != dofVptr);
        pylith::int_array fixedDOF((int*) dofVptr, numFixedDOF);
        ((pylith::bc::DirichletPoints*) objVptr)->fixedDOF(fixedDOF);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      cdef int* fixedDOF
      numFixedDOF = len(value)
      fixedDOF = <int*> malloc(numFixedDOF*sizeof(int))
      assert(fixedDOF != NULL)
      for i from 0 <= i < numFixedDOF:
        fixedDOF[i] = value[i]
      DirichletPoints_fixedDOF_set(self.thisptr, fixedDOF, numFixedDOF)
      free(fixedDOF)


  def setConstraintSizes(self, field, mesh):
    """
    Set number of degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraintSizes'
    #embed{ void DirichletPoints_setConstraintSizes(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletPoints*) objVptr)->setConstraintSizes(*field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletPoints_setConstraintSizes(self.thisptr, PyCObject_AsVoidPtr(field),
                                  ptrFromHandle(mesh))
    return


  def setConstraints(self, field, mesh):
    """
    Set which degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraints'
    #embed{ void DirichletPoints_setConstraints(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletPoints*) objVptr)->setConstraints(*field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletPoints_setConstraints(self.thisptr, PyCObject_AsVoidPtr(field), ptrFromHandle(mesh))
    return


  def setField(self, t, field, mesh):
    """
    Set values in field.
    """
    # create shim for method 'setField'
    #embed{ void DirichletPoints_setField(void* objVptr, double t, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletPoints*) objVptr)->setField(t, *field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletPoints_setField(self.thisptr, t, PyCObject_AsVoidPtr(field),
                          ptrFromHandle(mesh))
    return


  property useSolnIncr:
    def __set__(self, flag):
      """
      Set solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void DirichletPoints_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::bc::DirichletPoints*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      DirichletPoints_useSolnIncr_set(self.thisptr, flag)


# ----------------------------------------------------------------------
cdef class DirichletBoundary(BoundaryCondition):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* DirichletBoundary_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::bc::DirichletBoundary);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    BoundaryCondition.__init__(self)
    self.thisptr = DirichletBoundary_constructor()
    self.handle = self._createHandle()
    return


  property referenceTime:
    def __set__(self, value):
      """
      Set reference time for rate of change of values.
      """
      # create shim for method 'referenceTime'
      #embed{ void DirichletBoundary_referenceTime_set(void* objVptr, double value)
      try {
        assert(0 != objVptr);
        ((pylith::bc::DirichletBoundary*) objVptr)->referenceTime(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      DirichletBoundary_referenceTime_set(self.thisptr, value)


  property dbRate:
    def __set__(self, value):
      """
      Set spatial database for parameters of rate of change of values.
      """
      # create shim for method 'dbRate'
      #embed{ void DirichletBoundary_dbRate_set(void* objVptr, void* dbVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dbVptr);
        spatialdata::spatialdb::SpatialDB* db =
          (spatialdata::spatialdb::SpatialDB*) dbVptr;
        ((pylith::bc::DirichletBoundary*) objVptr)->dbRate(db);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_spatialdb_SpatialDB":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::spatialdb::SpatialDB'."
      DirichletBoundary_dbRate_set(self.thisptr, ptrFromHandle(value))


  property fixedDOF:
    def __set__(self, value):
      """
      Set fixed DOF.
      """
      # create shim for method 'fixedDOF'
      #embed{ void DirichletBoundary_fixedDOF_set(void* objVptr, int* dofVptr, int numFixedDOF)
      try {
        assert(0 != objVptr);
        assert(0 != dofVptr);
        pylith::int_array fixedDOF((int*) dofVptr, numFixedDOF);
        ((pylith::bc::DirichletBoundary*) objVptr)->fixedDOF(fixedDOF);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      cdef int* fixedDOF
      numFixedDOF = len(value)
      fixedDOF = <int*> malloc(numFixedDOF*sizeof(int))
      assert(fixedDOF != NULL)
      for i from 0 <= i < numFixedDOF:
        fixedDOF[i] = value[i]
      DirichletBoundary_fixedDOF_set(self.thisptr, fixedDOF, numFixedDOF)
      free(fixedDOF)


  def setConstraintSizes(self, field, mesh):
    """
    Set number of degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraintSizes'
    #embed{ void DirichletBoundary_setConstraintSizes(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletBoundary*) objVptr)->setConstraintSizes(*field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletBoundary_setConstraintSizes(self.thisptr, PyCObject_AsVoidPtr(field),
                                  ptrFromHandle(mesh))
    return


  def setConstraints(self, field, mesh):
    """
    Set which degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraints'
    #embed{ void DirichletBoundary_setConstraints(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletBoundary*) objVptr)->setConstraints(*field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletBoundary_setConstraints(self.thisptr, PyCObject_AsVoidPtr(field), ptrFromHandle(mesh))
    return


  def setField(self, t, field, mesh):
    """
    Set values in field.
    """
    # create shim for method 'setField'
    #embed{ void DirichletBoundary_setField(void* objVptr, double t, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::DirichletBoundary*) objVptr)->setField(t, *field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletBoundary_setField(self.thisptr, t, PyCObject_AsVoidPtr(field),
                          ptrFromHandle(mesh))
    return


  def boundaryMesh(self, mesh):
    """
    Get mesh associated with fields over boundary.
    """
    # create shim for method 'boundaryMesh'
    #embed{ void DirichletBoundary_boundaryMesh(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::SubMesh>* mesh = (ALE::Obj<pylith::SubMesh>*) meshVptr;
      *mesh = ((pylith::bc::DirichletBoundary*) objVptr)->boundaryMesh();
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    DirichletBoundary_boundaryMesh(self.thisptr, ptrFromHandle(mesh))
    return
    

  def vertexField(self, name, mesh, fields=None):
    """
    Get cell field.
    """
    # create shim for method 'vertexField'
    #embed{ void* DirichletBoundary_vertexField(void* objVptr, int* fieldPtr, char* name, void* meshVptr, void* fieldsVptr)
    void* result = 0;
    try {
      assert(0 != objVptr);
      assert(0 != fieldPtr);
      assert(0 != name);
      assert(0 != meshVptr);
      pylith::bc::DirichletBoundary* bc = (pylith::bc::DirichletBoundary*) objVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      pylith::VectorFieldEnum fieldType;
      const ALE::Obj<pylith::real_section_type>& field =
        bc->vertexField(&fieldType, name, *mesh, fields);
      *fieldPtr = fieldType;
      result = (void*) &field;
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    if None != fields:
      if not fields.name == "pylith_topology_FieldsManager":
        raise TypeError, \
              "Argument 'fields' must be extension module type " \
              "'pylith::topology::FieldsManager'."
    cdef void* ptr
    cdef int fieldType
    if None != fields:
      ptr = DirichletBoundary_vertexField(self.thisptr, &fieldType, name,
                              ptrFromHandle(mesh), ptrFromHandle(fields))
    else:
      ptr = DirichletBoundary_vertexField(self.thisptr, &fieldType, name,
                              ptrFromHandle(mesh), NULL)
    return (PyCObject_FromVoidPtr(ptr, NULL), fieldType)
    

  property useSolnIncr:
    def __set__(self, flag):
      """
      Set solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void DirichletBoundary_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::bc::DirichletBoundary*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      DirichletBoundary_useSolnIncr_set(self.thisptr, flag)


# ----------------------------------------------------------------------
cdef class AbsorbingDampers(BoundaryCondition):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* AbsorbingDampers_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::bc::AbsorbingDampers);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    BoundaryCondition.__init__(self)
    self.thisptr = AbsorbingDampers_constructor()
    self.handle = self._createHandle()
    return


  def integrateResidual(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator.
    """
    # create shim for method 'integrateResidual'
    #embed{ void AbsorbingDampers_integrateResidual(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::bc::AbsorbingDampers*) objVptr)->integrateResidual(*residual,
                                                            t, fields, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    AbsorbingDampers_integrateResidual(self.thisptr, 
                                 PyCObject_AsVoidPtr(residual),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh),
				 ptrFromHandle(cs))
    return


  def integrateJacobian(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with operator.
    """
    # create shim for method 'integrateJacobian'
    #embed{ void AbsorbingDampers_integrateJacobian(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::bc::AbsorbingDampers*) objVptr)->integrateJacobian(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    AbsorbingDampers_integrateJacobian(self.thisptr,
                                 PyCObject_AsVoidPtr(mat),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh))
    return


  def integrateResidualAssembled(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator that do
    not require assembly over cells, vertices, or processors.
    """
    # create shim for method 'integrateResidualAssembled'
    #embed{ void AbsorbingDampers_integrateResidualAssembled(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::bc::AbsorbingDampers*) objVptr)->integrateResidualAssembled(*residual,
                                                            t, fields, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    AbsorbingDampers_integrateResidualAssembled(self.thisptr, 
                                                PyCObject_AsVoidPtr(residual),
                                                t,
                                                ptrFromHandle(fields),
                                                ptrFromHandle(mesh),
                                                ptrFromHandle(cs))
    return


  def integrateJacobianAssembled(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with
    operator that do not require assembly over cells, vertices, or
    processors.
    """
    # create shim for method 'integrateJacobianAssembled'
    #embed{ void AbsorbingDampers_integrateJacobianAssembled(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::bc::AbsorbingDampers*) objVptr)->integrateJacobianAssembled(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    AbsorbingDampers_integrateJacobianAssembled(self.thisptr,
                                                PyCObject_AsVoidPtr(mat),
                                                t,
                                                ptrFromHandle(fields),
                                                ptrFromHandle(mesh))
    return


  def updateState(self, t, fields, mesh):
    """
    Update state variables as needed.
    """
    # create shim for method 'updateState'
    #embed{ void AbsorbingDampers_updateState(void* objVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::AbsorbingDampers*) objVptr)->updateState(t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if fields.name != "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument 'fields' must be extension module type 'FieldsManager'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    AbsorbingDampers_updateState(self.thisptr,
                           t,
                           ptrFromHandle(fields),
                           ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, BoundaryCondition_destructor)


  property quadrature:
    def __set__(self, q):
      """
      Set quadrature.
      """
      # create shim for method 'quadrature'
      #embed{ void AbsorbingDampers_quadrature_set(void* objVptr, void* qVptr)
      try {
        assert(0 != objVptr);
        pylith::feassemble::Quadrature* quadrature =
          (pylith::feassemble::Quadrature*) qVptr;
        ((pylith::bc::AbsorbingDampers*) objVptr)->quadrature(quadrature);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      AbsorbingDampers_quadrature_set(self.thisptr, ptrFromHandle(q))


  property normalizer:
    def __set__(self, value):
      """
      Set nondimensionalizer.
      """
      # create shim for method 'normalizer'
      #embed{ void AbsorbingDampers_normalizer_set(void* objVptr, void* dimVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dimVptr);
        spatialdata::units::Nondimensional* dim =
          (spatialdata::units::Nondimensional*) dimVptr;
        ((pylith::bc::AbsorbingDampers*) objVptr)->normalizer(*dim);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_units_Nondimensional":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::units::Nondimensional'."
      AbsorbingDampers_normalizer_set(self.thisptr, ptrFromHandle(value))


  property timeStep:
    def __set__(self, dt):
      """
      Set timeStep.
      """
      # create shim for method 'timeStep'
      #embed{ void AbsorbingDampers_timeStep_set(void* objVptr, double dt)
      try {
        assert(0 != objVptr);
        ((pylith::bc::AbsorbingDampers*) objVptr)->timeStep(dt);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      AbsorbingDampers_timeStep_set(self.thisptr, dt)


  property stableTimeStep:
    def __get__(self):
      """
      Get stable time step.
      """
      # create shim for method 'stableTimeStep'
      #embed{ double AbsorbingDampers_stableTimeStep_get(void* objVptr)
      double result = 0.0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::bc::AbsorbingDampers*) objVptr)->stableTimeStep();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return AbsorbingDampers_stableTimeStep_get(self.thisptr)


  property needNewJacobian:
    def __get__(self):
      """
      Set timeStep.
      """
      # create shim for method 'needNewJacobian'
      #embed{ int AbsorbingDampers_needNewJacobian_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::bc::AbsorbingDampers*) objVptr)->needNewJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return AbsorbingDampers_needNewJacobian_get(self.thisptr)


  property useSolnIncr:
    def __set__(self, flag):
      """
      Set solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void AbsorbingDampers_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::bc::AbsorbingDampers*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      AbsorbingDampers_useSolnIncr_set(self.thisptr, flag)


# ----------------------------------------------------------------------
cdef class Neumann(BoundaryCondition):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* Neumann_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::bc::Neumann);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    BoundaryCondition.__init__(self)
    self.thisptr = Neumann_constructor()
    self.handle = self._createHandle()
    return


    BoundaryCondition.__init__(self)
    self.thisptr = Neumann_constructor()
    self.handle = self._createHandle()


  def integrateResidual(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator.
    """
    # create shim for method 'integrateResidual'
    #embed{ void Neumann_integrateResidual(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::bc::Neumann*) objVptr)->integrateResidual(*residual,
                                                            t, fields, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    Neumann_integrateResidual(self.thisptr, 
                                 PyCObject_AsVoidPtr(residual),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh),
				 ptrFromHandle(cs))
    return


  def integrateJacobian(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with operator.
    """
    # create shim for method 'integrateJacobian'
    #embed{ void Neumann_integrateJacobian(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::bc::Neumann*) objVptr)->integrateJacobian(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Neumann_integrateJacobian(self.thisptr,
                                 PyCObject_AsVoidPtr(mat),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh))
    return


  def integrateResidualAssembled(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator that do
    not require assembly over cells, vertices, or processors.
    """
    # create shim for method 'integrateResidualAssembled'
    #embed{ void Neumann_integrateResidualAssembled(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::bc::Neumann*) objVptr)->integrateResidualAssembled(*residual,
                                                            t, fields, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    Neumann_integrateResidualAssembled(self.thisptr, 
                                       PyCObject_AsVoidPtr(residual),
                                       t,
                                       ptrFromHandle(fields),
                                       ptrFromHandle(mesh),
                                       ptrFromHandle(cs))
    return


  def integrateJacobianAssembled(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with
    operator that do not require assembly over cells, vertices, or
    processors.
    """
    # create shim for method 'integrateJacobianAssembled'
    #embed{ void Neumann_integrateJacobianAssembled(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::bc::Neumann*) objVptr)->integrateJacobianAssembled(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Neumann_integrateJacobianAssembled(self.thisptr,
                                       PyCObject_AsVoidPtr(mat),
                                       t,
                                       ptrFromHandle(fields),
                                       ptrFromHandle(mesh))
    return


  def updateState(self, t, fields, mesh):
    """
    Update state variables as needed.
    """
    # create shim for method 'updateState'
    #embed{ void Neumann_updateState(void* objVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::bc::Neumann*) objVptr)->updateState(t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if fields.name != "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument 'fields' must be extension module type 'FieldsManager'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Neumann_updateState(self.thisptr,
                           t,
                           ptrFromHandle(fields),
                           ptrFromHandle(mesh))
    return


  def boundaryMesh(self, mesh):
    """
    Get mesh associated with fields over boundary.
    """
    # create shim for method 'boundaryMesh'
    #embed{ void Neumann_boundaryMesh(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::SubMesh>* mesh = (ALE::Obj<pylith::SubMesh>*) meshVptr;
      *mesh = ((pylith::bc::Neumann*) objVptr)->boundaryMesh();
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    Neumann_boundaryMesh(self.thisptr, ptrFromHandle(mesh))
    return
    

  def cellField(self, name, mesh, fields=None):
    """
    Get cell field.
    """
    # create shim for method 'cellField'
    #embed{ void* Neumann_cellField(void* objVptr, int* fieldPtr, char* name, void* meshVptr, void* fieldsVptr)
    void* result = 0;
    try {
      assert(0 != objVptr);
      assert(0 != fieldPtr);
      assert(0 != name);
      assert(0 != meshVptr);
      pylith::bc::Neumann* bc = (pylith::bc::Neumann*) objVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      pylith::VectorFieldEnum fieldType;
      const ALE::Obj<pylith::real_section_type>& field =
        bc->cellField(&fieldType, name, *mesh, fields);
      *fieldPtr = fieldType;
      result = (void*) &field;
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    if None != fields:
      if not fields.name == "pylith_topology_FieldsManager":
        raise TypeError, \
              "Argument 'fields' must be extension module type " \
              "'pylith::topology::FieldsManager'."
    cdef void* ptr
    cdef int fieldType
    if None != fields:
      ptr = Neumann_cellField(self.thisptr, &fieldType, name,
                              ptrFromHandle(mesh), ptrFromHandle(fields))
    else:
      ptr = Neumann_cellField(self.thisptr, &fieldType, name,
                              ptrFromHandle(mesh), NULL)
    return (PyCObject_FromVoidPtr(ptr, NULL), fieldType)
    

  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, BoundaryCondition_destructor)


  property quadrature:
    def __set__(self, q):
      """
      Set quadrature.
      """
      # create shim for method 'quadrature'
      #embed{ void Neumann_quadrature_set(void* objVptr, void* qVptr)
      try {
        assert(0 != objVptr);
        pylith::feassemble::Quadrature* quadrature =
          (pylith::feassemble::Quadrature*) qVptr;
        ((pylith::bc::Neumann*) objVptr)->quadrature(quadrature);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      Neumann_quadrature_set(self.thisptr, ptrFromHandle(q))


  property normalizer:
    def __set__(self, value):
      """
      Set nondimensionalizer.
      """
      # create shim for method 'normalizer'
      #embed{ void Neumann_normalizer_set(void* objVptr, void* dimVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dimVptr);
        spatialdata::units::Nondimensional* dim =
          (spatialdata::units::Nondimensional*) dimVptr;
        ((pylith::bc::Neumann*) objVptr)->normalizer(*dim);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_units_Nondimensional":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::units::Nondimensional'."
      Neumann_normalizer_set(self.thisptr, ptrFromHandle(value))


  property timeStep:
    def __set__(self, dt):
      """
      Set timeStep.
      """
      # create shim for method 'timeStep'
      #embed{ void Neumann_timeStep_set(void* objVptr, double dt)
      try {
        assert(0 != objVptr);
        ((pylith::bc::Neumann*) objVptr)->timeStep(dt);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Neumann_timeStep_set(self.thisptr, dt)


  property stableTimeStep:
    def __get__(self):
      """
      Get stable time step.
      """
      # create shim for method 'stableTimeStep'
      #embed{ double Neumann_stableTimeStep_get(void* objVptr)
      double result = 0.0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::bc::Neumann*) objVptr)->stableTimeStep();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Neumann_stableTimeStep_get(self.thisptr)


  property needNewJacobian:
    def __get__(self):
      """
      Set timeStep.
      """
      # create shim for method 'needNewJacobian'
      #embed{ int Neumann_needNewJacobian_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::bc::Neumann*) objVptr)->needNewJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Neumann_needNewJacobian_get(self.thisptr)


  property useSolnIncr:
    def __set__(self, flag):
      """
      Set solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void Neumann_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::bc::Neumann*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Neumann_useSolnIncr_set(self.thisptr, flag)


# End of file 

