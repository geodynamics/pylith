# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/meshio/MeshIO.hh"
#include "pylith/meshio/MeshIOAscii.hh"
#include "pylith/meshio/MeshIOLagrit.hh"
#include "pylith/meshio/SolutionIO.hh"
#include "pylith/meshio/SolutionIOVTK.hh"
#include "pylith/meshio/OutputManager.hh"
#include "pylith/meshio/DataWriter.hh"
#include "pylith/meshio/DataWriterVTK.hh"

#if defined(ENABLE_CUBIT)
#include "pylith/meshio/MeshIOCubit.hh"
#endif

#include <stdexcept>
#include <assert.h>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

cdef void MeshIO_destructor(void* obj):
  """
  Destroy MeshIO object.
  """
  # create shim for destructor
  #embed{ void MeshIO_destructor_cpp(void* pObj)
  pylith::meshio::MeshIO* io = (pylith::meshio::MeshIO*) pObj;
  delete io;
  #}embed
  MeshIO_destructor_cpp(obj)
  return

cdef void SolutionIO_destructor(void* obj):
  """
  Destroy SolutionIO object.
  """
  # create shim for destructor
  #embed{ void SolutionIO_destructor_cpp(void* pObj)
  pylith::meshio::SolutionIO* io = (pylith::meshio::SolutionIO*) pObj;
  delete io;
  #}embed
  SolutionIO_destructor_cpp(obj)
  return

# ----------------------------------------------------------------------
cdef class MeshIO:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_meshio_MeshIO"
    return


  def read(self, mesh):
    """
    Read mesh from file.
    """
    # create shim for method 'read'
    #embed{ void MeshIO_read(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::MeshIO*) objVptr)->read(mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    MeshIO_read(self.thisptr, ptrFromHandle(mesh))
    return


  def write(self, mesh):
    """
    Read write to file.
    """
    # create shim for method 'write'
    #embed{ void MeshIO_write(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::MeshIO*) objVptr)->write(mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    MeshIO_write(self.thisptr, ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, MeshIO_destructor)


  property interpolate:
    def __set__(self, flag):
      """Set interpolate."""
      # create shim for method 'interpolate'
      #embed{ void MeshIO_interpolate_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIO*) objVptr)->interpolate(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIO_interpolate_set(self.thisptr, flag)

    def __get__(self):
      """Get interpolate."""
      # create shim for method 'interpolate'
      #embed{ int MeshIO_interpolate_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::meshio::MeshIO*) objVptr)->interpolate();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIO_interpolate_get(self.thisptr)


  property debug:
    def __set__(self, flag):
      """Set debug."""
      # create shim for method 'debug'
      #embed{ void MeshIO_debug_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIO*) objVptr)->debug(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIO_debug_set(self.thisptr, flag)

    def __get__(self):
      """Get debug."""
      # create shim for method 'debug'
      #embed{ int MeshIO_debug_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::meshio::MeshIO*) objVptr)->debug();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIO_debug_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class MeshIOAscii(MeshIO):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* MeshIOAscii_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::meshio::MeshIOAscii);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    MeshIO.__init__(self)
    self.thisptr = MeshIOAscii_constructor()
    self.handle = self._createHandle()
    return


  property filename:
    def __set__(self, name):
      """Set filename."""
      # create shim for method 'filename'
      #embed{ void MeshIOAscii_filename_set(void* objVptr, char* name)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIOAscii*) objVptr)->filename(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIOAscii_filename_set(self.thisptr, name)

    def __get__(self):
      """Get filename."""
      # create shim for method 'filename'
      #embed{ char* MeshIOAscii_filename_get(void* objVptr)
      char* result = 0;
      try {
        assert(0 != objVptr);
        result = (char*) ((pylith::meshio::MeshIOAscii*) objVptr)->filename();
        assert(0 != result);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIOAscii_filename_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class MeshIOCubit(MeshIO):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* MeshIOCubit_constructor()
    #if defined(ENABLE_CUBIT)
    void* result = 0;
    try {
      result = (void*)(new pylith::meshio::MeshIOCubit);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #else
    throw std::logic_error("Not configured to use CUBIT.");
    return 0;
    #endif
    #}embed

    MeshIO.__init__(self)
    self.thisptr = MeshIOCubit_constructor()
    self.handle = self._createHandle()
    return


  property filename:
    def __set__(self, name):
      """Set filename."""
      # create shim for method 'filename'
      #embed{ void MeshIOCubit_filename_set(void* objVptr, char* name)
      #if defined(ENABLE_CUBIT)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIOCubit*) objVptr)->filename(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #else
      throw std::logic_error("Not configured to use CUBIT.");
      #endif
      #}embed
      MeshIOCubit_filename_set(self.thisptr, name)

    def __get__(self):
      """Get filename."""
      # create shim for method 'filename'
      #embed{ char* MeshIOCubit_filename_get(void* objVptr)
      #if defined(ENABLE_CUBIT)
      char* result = 0;
      try {
        assert(0 != objVptr);
        result = (char*) ((pylith::meshio::MeshIOCubit*) objVptr)->filename();
        assert(0 != result);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #else
      throw std::logic_error("Not configured to use CUBIT.");
      return 0;
      #endif
      #}embed
      return MeshIOCubit_filename_get(self.thisptr)

# ----------------------------------------------------------------------
cdef class MeshIOLagrit(MeshIO):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* MeshIOLagrit_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::meshio::MeshIOLagrit);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    MeshIO.__init__(self)
    self.thisptr = MeshIOLagrit_constructor()
    self.handle = self._createHandle()
    return


  property filenameGmv:
    def __set__(self, name):
      """Set filename."""
      # create shim for method 'filenameGmv'
      #embed{ void MeshIOLagrit_filenameGmv_set(void* objVptr, char* name)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIOLagrit*) objVptr)->filenameGmv(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIOLagrit_filenameGmv_set(self.thisptr, name)

    def __get__(self):
      """Get filename."""
      # create shim for method 'filenameGmv'
      #embed{ char* MeshIOLagrit_filenameGmv_get(void* objVptr)
      char* result = 0;
      try {
        assert(0 != objVptr);
        result = (char*) ((pylith::meshio::MeshIOLagrit*) objVptr)->filenameGmv();
        assert(0 != result);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIOLagrit_filenameGmv_get(self.thisptr)


  property filenamePset:
    def __set__(self, name):
      """Set filename."""
      # create shim for method 'filenamePset'
      #embed{ void MeshIOLagrit_filenamePset_set(void* objVptr, char* name)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIOLagrit*) objVptr)->filenamePset(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIOLagrit_filenamePset_set(self.thisptr, name)

    def __get__(self):
      """Get filename."""
      # create shim for method 'filenamePset'
      #embed{ char* MeshIOLagrit_filenamePset_get(void* objVptr)
      char* result = 0;
      try {
        assert(0 != objVptr);
        result = (char*) ((pylith::meshio::MeshIOLagrit*) objVptr)->filenamePset();
        assert(0 != result);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIOLagrit_filenamePset_get(self.thisptr)


  property flipEndian:
    def __set__(self, flag):
      """Set flip endian flag."""
      # create shim for method 'flipEndian'
      #embed{ void MeshIOLagrit_flipEndian_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::MeshIOLagrit*) objVptr)->flipEndian(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      MeshIOLagrit_flipEndian_set(self.thisptr, flag)

    def __get__(self):
      """Get flip endian flag."""
      # create shim for method 'flipEndian'
      #embed{ int MeshIOLagrit_flipEndian_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::meshio::MeshIOLagrit*) objVptr)->flipEndian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return MeshIOLagrit_flipEndian_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class SolutionIO:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_meshio_SolutionIO"
    return


  def open(self, mesh):
    """
    Open solution files.
    """
    # create shim for method 'open'
    #embed{ void SolutionIO_open(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::SolutionIO*) objVptr)->open(*mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    SolutionIO_open(self.thisptr, ptrFromHandle(mesh))
    return


  def close(self):
    """
    Close solution files.
    """
    # create shim for method 'close'
    #embed{ void SolutionIO_close(void* objVptr)
    try {
      assert(0 != objVptr);
      ((pylith::meshio::SolutionIO*) objVptr)->close();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    SolutionIO_close(self.thisptr)
    return


  def openTimeStep(self, t, mesh, cs):
    """
    Prepare for writing solution to file.
    """
    # create shim for method 'openTimeStep'
    #embed{ void SolutionIO_openTimeStep(void* objVptr, double t, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::meshio::SolutionIO*) objVptr)->openTimeStep(t, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type 'CoordSys'."
    SolutionIO_openTimeStep(self.thisptr, t, 
                            ptrFromHandle(mesh), ptrFromHandle(cs))
    return


  def closeTimeStep(self):
    """
    Prepare for writing solution to file.
    """
    # create shim for method 'closeTimeStep'
    #embed{ void SolutionIO_closeTimeStep(void* objVptr)
    try {
      assert(0 != objVptr);
      ((pylith::meshio::SolutionIO*) objVptr)->closeTimeStep();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    SolutionIO_closeTimeStep(self.thisptr)
    return


  def writeVertexField(self, t, name, field, mesh):
    """
    Write field over vertices to file.
    """
    # create shim for method 'writeVertxField'
    #embed{ void SolutionIO_writeVertexField(void* objVptr, double t, char* name, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != name);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::SolutionIO*) objVptr)->writeVertexField(t, name,
                                                                *field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    SolutionIO_writeVertexField(self.thisptr, t, name, fieldVptr, 
                                ptrFromHandle(mesh))
    return


  def writeCellField(self, t, name, field, mesh):
    """
    Write field over cells to file.
    """
    # create shim for method 'writeCellField'
    #embed{ void SolutionIO_writeCellField(void* objVptr, double t, char* name, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != name);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::SolutionIO*) objVptr)->writeCellField(t, name, *field,
                                                              *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    SolutionIO_writeCellField(self.thisptr, t, name, fieldVptr,
                              ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, SolutionIO_destructor)


  property coordsys:
    def __set__(self, cs):
      """Set coordinate system."""
      # create shim for method 'coordsys'
      #embed{ void SolutionIO_coordsys_set(void* objVptr, void* csVptr)
      try {
        assert(0 != objVptr);
        assert(0 != csVptr);
        spatialdata::geocoords::CoordSys* cs =
          (spatialdata::geocoords::CoordSys*) csVptr;
        ((pylith::meshio::SolutionIO*) objVptr)->coordsys(cs);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      SolutionIO_coordsys_set(self.thisptr, ptrFromHandle(cs))


# ----------------------------------------------------------------------
cdef class SolutionIOVTK(SolutionIO):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* SolutionIOVTK_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::meshio::SolutionIOVTK);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    SolutionIO.__init__(self)
    self.thisptr = SolutionIOVTK_constructor()
    self.handle = self._createHandle()
    return


  property filename:
    def __set__(self, name):
      """Set filename."""
      # create shim for method 'filename'
      #embed{ void SolutionIOVTK_filename_set(void* objVptr, char* name)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::SolutionIOVTK*) objVptr)->filename(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      SolutionIOVTK_filename_set(self.thisptr, name)

    def __get__(self):
      """Get filename."""
      # create shim for method 'filename'
      #embed{ char* SolutionIOVTK_filename_get(void* objVptr)
      char* result = 0;
      try {
        assert(0 != objVptr);
        result = (char*) ((pylith::meshio::SolutionIOVTK*) objVptr)->filename();
        assert(0 != result);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return SolutionIOVTK_filename_get(self.thisptr)

  property timeFormat:
    def __set__(self, format):
      """Set timeFormat."""
      # create shim for method 'timeFormat'
      #embed{ void SolutionIOVTK_timeFormat_set(void* objVptr, char* format)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::SolutionIOVTK*) objVptr)->timeFormat(format);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      SolutionIOVTK_timeFormat_set(self.thisptr, format)


# ----------------------------------------------------------------------
cdef void OutputManager_destructor(void* obj):
  """
  Destroy OutputManager object.
  """
  # create shim for destructor
  #embed{ void OutputManager_destructor_cpp(void* pObj)
  pylith::meshio::OutputManager* io = (pylith::meshio::OutputManager*) pObj;
  delete io;
  #}embed
  OutputManager_destructor_cpp(obj)
  return

cdef class OutputManager:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_meshio_OutputManager"
    return


  def open(self, mesh, cs):
    """
    Open output file.
    """
    # create shim for method 'open'
    #embed{ void OutputManager_open(void* objVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != csVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::meshio::OutputManager*) objVptr)->open(*mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type 'CoordSys'."
    OutputManager_open(self.thisptr, ptrFromHandle(mesh),
                       ptrFromHandle(cs))
    return


  def close(self):
    """
    Close solution files.
    """
    # create shim for method 'close'
    #embed{ void OutputManager_close(void* objVptr)
    try {
      assert(0 != objVptr);
      ((pylith::meshio::OutputManager*) objVptr)->close();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    OutputManager_close(self.thisptr)
    return


  def writeFields(self, t, fields, mesh, cs):
    """
    Write fields to file.
    """
    # create shim for method 'writeFields'
    #embed{ void OutputManager_writeFields(void* objVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      pylith::topology::FieldsManager* fields = 
        (pylith::topology::FieldsManager*) fieldsVptr;
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::meshio::OutputManager*) objVptr)->writeFields(t, fields,
                                                              *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not fields.name == "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument must be extension module type 'FieldsManager'."
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    OutputManager_writeFields(self.thisptr, t, ptrFromHandle(fields), 
                              ptrFromHandle(mesh), ptrFromHandle(cs))
    return


  def openTimeStep(self, t, mesh, cs):
    """
    Prepare for writing solution to file.
    """
    # create shim for method 'openTimeStep'
    #embed{ void OutputManager_openTimeStep(void* objVptr, double t, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::meshio::OutputManager*) objVptr)->openTimeStep(t, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type 'CoordSys'."
    OutputManager_openTimeStep(self.thisptr, t, 
                            ptrFromHandle(mesh), ptrFromHandle(cs))
    return


  def closeTimeStep(self):
    """
    Prepare for writing solution to file.
    """
    # create shim for method 'closeTimeStep'
    #embed{ void OutputManager_closeTimeStep(void* objVptr)
    try {
      assert(0 != objVptr);
      ((pylith::meshio::OutputManager*) objVptr)->closeTimeStep();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    OutputManager_closeTimeStep(self.thisptr)
    return


  def appendVertexField(self, t, name, field, mesh):
    """
    Append field over vertices to file.
    """
    # create shim for method 'appendVertxField'
    #embed{ void OutputManager_appendVertexField(void* objVptr, double t, char* name, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != name);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::OutputManager*) objVptr)->appendVertexField(t, name,
                                                                *field, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    OutputManager_appendVertexField(self.thisptr, t, name, fieldVptr, 
                                ptrFromHandle(mesh))
    return


  def appendCellField(self, t, name, field, mesh):
    """
    Append field over cells to file.
    """
    # create shim for method 'appendCellField'
    #embed{ void OutputManager_appendCellField(void* objVptr, double t, char* name, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != name);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ((pylith::meshio::OutputManager*) objVptr)->appendCellField(t, name, *field,
                                                              *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    OutputManager_appendCellField(self.thisptr, t, name, fieldVptr,
                              ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, OutputManager_destructor)


  property coordsys:
    def __set__(self, cs):
      """Set coordinate system."""
      # create shim for method 'coordsys'
      #embed{ void OutputManager_coordsys_set(void* objVptr, void* csVptr)
      try {
        assert(0 != objVptr);
        assert(0 != csVptr);
        spatialdata::geocoords::CoordSys* cs =
          (spatialdata::geocoords::CoordSys*) csVptr;
        ((pylith::meshio::OutputManager*) objVptr)->coordsys(cs);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      OutputManager_coordsys_set(self.thisptr, ptrFromHandle(cs))


  property writer:
    def __set__(self, writer):
      """
      Writer for finite-element data.
      """
      # create shim for method 'writer'
      #embed{ void OutputManager_writer_set(void* objVptr, void* writerVptr)
      try {
        assert(0 != objVptr);
        assert(0 != writerVptr);
        pylith::meshio::DataWriter* writer = 
          (pylith::meshio::DataWriter*) writerVptr;
        ((pylith::meshio::OutputManager*) objVptr)->writer(writer);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      OutputManager_writer_set(self.thisptr, ptrFromHandle(writer))


  property vertexFields:
    def __set__(self, fields):
      """
      Set names and mesh labels of vertex fields
      """
      # create shim for method 'vertexFields'
      #embed{ void OutputManager_vertexFields_set(void* objVptr, char** names, char** labels, int numFields)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::OutputManager*) objVptr)->vertexFields((const char**) names, 
                                                                 (const char**) labels,
                                                                 numFields);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed

      cdef char** names
      names = NULL
      cdef char** labels
      labels = NULL
      numFields = len(fields)
      if numFields > 0:
        names = <char**> malloc(numFields*sizeof(char*))
        labels = <char**> malloc(numFields*sizeof(char*))
      keys = fields.keys()
      values = fields.values()
      for i from 0 <= i <= numFields:
        strsize = len(keys[i])
        names[i] = <char*> malloc(1+strsize*sizeof(char))
        tmp = keys[i]
        strcpy(names[i], tmp)
        strsize = len(values[i])
        labels[i] = <char*> malloc(1+strsize*sizeof(char))
        tmp = values[i]
        strcpy(labels[i], tmp)
      
      OutputManager_vertexFields_set(self.thisptr, names, labels, numFields)

      # memory cleanup
      for i from 0 <= i < numFields:
        free(<void*> names[i])
        free(<void*> labels[i])
      free(<void*> names)
      free(<void*> labels)


  property cellFields:
    def __set__(self, fields):
      """
      Set names and mesh labels of cell fields
      """
      # create shim for method 'cellFields'
      #embed{ void OutputManager_cellFields_set(void* objVptr, char** names, char** labels, int numFields)
      try {
        assert(0 != objVptr);
        ((pylith::meshio::OutputManager*) objVptr)->cellFields((const char**) names, 
                                                               (const char**) labels,
                                                                 numFields);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed

      cdef char** names
      names = NULL
      cdef char** labels
      labels = NULL
      numFields = len(fields)
      if numFields > 0:
        names = <char**> malloc(numFields*sizeof(char*))
        labels = <char**> malloc(numFields*sizeof(char*))
      keys = fields.keys()
      values = fields.values()
      for i from 0 <= i <= numFields:
        strsize = len(keys[i])
        names[i] = <char*> malloc(1+strsize*sizeof(char))
        tmp = keys[i]
        strcpy(names[i], tmp)
        strsize = len(values[i])
        labels[i] = <char*> malloc(1+strsize*sizeof(char))
        tmp = values[i]
        strcpy(labels[i], tmp)
      
      OutputManager_cellFields_set(self.thisptr, names, labels, numFields)

      # memory cleanup
      for i from 0 <= i < numFields:
        free(<void*> names[i])
        free(<void*> labels[i])
      free(<void*> names)
      free(<void*> labels)


  property vertexFilter:
    def __set__(self, filter):
      """
      Set vertex filter.
      """
      # create shim for method 'vertexFilter'
      #embed{ void OutputManager_vertexFilter_set(void* objVptr, void* filterVptr)
      try {
        assert(0 != objVptr);
        assert(0 != filterVptr);
        pylith::meshio::VertexFilter* filter = 
          (pylith::meshio::VertexFilter*) filterVptr;
        ((pylith::meshio::OutputManager*) objVptr)->vertexFilter(filter);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      OutputManager_vertexFilter_set(self.thisptr, ptrFromHandle(filter))


  property cellFilter:
    def __set__(self, filter):
      """
      Set cell filter.
      """
      # create shim for method 'cellFilter'
      #embed{ void OutputManager_cellFilter_set(void* objVptr, void* filterVptr)
      try {
        assert(0 != objVptr);
        assert(0 != filterVptr);
        pylith::meshio::CellFilter* filter = 
          (pylith::meshio::CellFilter*) filterVptr;
        ((pylith::meshio::OutputManager*) objVptr)->cellFilter(filter);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      OutputManager_cellFilter_set(self.thisptr, ptrFromHandle(filter))


# End of file
