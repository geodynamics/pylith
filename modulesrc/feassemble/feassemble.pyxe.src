# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/feassemble/Quadrature.hh"
#include "pylith/feassemble/Quadrature1D.hh"
#include "pylith/feassemble/Quadrature1Din2D.hh"
#include "pylith/feassemble/Quadrature1Din3D.hh"
#include "pylith/feassemble/Quadrature2D.hh"
#include "pylith/feassemble/Quadrature2Din3D.hh"
#include "pylith/feassemble/Quadrature3D.hh"

#include "pylith/feassemble/Integrator.hh"
#include "pylith/feassemble/IntegratorExplicit.hh"
#include "pylith/feassemble/ExplicitElasticity.hh"

#include <assert.h>
#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
    ctypedef unsigned long size_t
    void* malloc(size_t size)
    void free(void* mem)

# ----------------------------------------------------------------------
cdef class Quadrature:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_Quadrature"
    return


  def initialize(self, basis, basisDeriv, quadPts, quadWts,
                 cellDim, numCorners, numQuadPts, spaceDim):
    """
    Set basis functions and their derivatives, and coordinates and
    weights of quadrature points.

    @param basis Basis functions evaluated at the quadrature points
    @param basisDeriv Basis function derivatives evaluated at quad pts
    @param quadPts Coordinates of quadrature points in reference cell
    @param quadWts Weights of quadrature points
    @param cellDim Dimension of reference cell
    @param numCorners Number of vertices in reference cell
    @param numQuadPts Number of quadrature points
    @param spaceDim Number of dimensions associated with cell vertices
    """
    # create shim for method 'initialize'
    #embed{ void Quadrature_initialize(void* pObj, double* basis, double* basisDeriv, double* quadPts, double* quadWts, int cellDim, int numCorners, int numQuadPts, int spaceDim)
    try {
      ((pylith::feassemble::Quadrature*) pObj)->initialize(basis, basisDeriv,
                                                           quadPts, quadWts,
                                                           cellDim, numCorners,
                                                           numQuadPts, spaceDim);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    import spatialdata.utils.simplearray

    # basis
    basis = spatialdata.utils.simplearray.objAsSimpleArray(basis)
    if not basis.isCompatible(nd=2, simpletype="double",
                              contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basis' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != basis.shape[0] or numCorners != basis.shape[1]:
      raise TypeError, \
            "Shape of argument 'basis' must be (numQuadPts, numCorners)."

    # basisDeriv
    basisDeriv = spatialdata.utils.simplearray.objAsSimpleArray(basisDeriv)
    if not basisDeriv.isCompatible(nd=3, simpletype="double",
                                   contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisDeriv' must be a contiguous, 3-D array " \
            "of type double."
    if numQuadPts != basisDeriv.shape[0] or \
           numCorners != basisDeriv.shape[1] or \
           cellDim != basisDeriv.shape[2]:
      raise TypeError, \
            "Shape of argument 'basisDeriv' must be (numQuadPts, " \
            "numCorners, cellDim)."

    # quadPts
    quadPts = spatialdata.utils.simplearray.objAsSimpleArray(quadPts)
    if not quadPts.isCompatible(nd=2, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadPts' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != quadPts.shape[0] or cellDim != quadPts.shape[1]:
      raise TypeError, \
            "Shape of argument 'quadPts' must be (numQuadPts, cellDim)."

    # quadWts
    quadWts = spatialdata.utils.simplearray.objAsSimpleArray(quadWts)
    if not quadWts.isCompatible(nd=1, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadWts' must be a contiguous, 1-D array " \
            "of type double."
    if numQuadPts != quadWts.shape[0]:
      raise TypeError, \
            "Shape of argument 'quadWts' must be (numQuadPts)."

    cdef double* basisCpp
    cdef double* basisDerivCpp
    cdef double* quadPtsCpp
    cdef double* quadWtsCpp
    basisCpp = <double*> PyCObject_AsVoidPtr(basis.data)
    basisDerivCpp = <double*> PyCObject_AsVoidPtr(basisDeriv.data)
    quadPtsCpp = <double*> PyCObject_AsVoidPtr(quadPts.data)
    quadWtsCpp = <double*> PyCObject_AsVoidPtr(quadWts.data)

    Quadrature_initialize(self.thisptr, basisCpp, basisDerivCpp,
                          quadPtsCpp, quadWtsCpp,
                          cellDim, numCorners,
                          numQuadPts, spaceDim)
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    # create shim for destructor
    #embed{ void Quadrature_destructor(void* pObj)
    try {
      pylith::feassemble::Quadrature* pQ =
        (pylith::feassemble::Quadrature*) pObj;
      delete pQ;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, Quadrature_destructor)


  property minJacobian:
    def __set__(self, value):
      """Set minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ void Quadrature_minJacobian_set(void* pObj, double value)
      try {
        ((pylith::feassemble::Quadrature*) pObj)->minJacobian(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Quadrature_minJacobian_set(self.thisptr, value)

    def __get__(self):
      """Get minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ double Quadrature_minJacobian_get(void* pObj)
      double result = 0;
      try {
        result = ((pylith::feassemble::Quadrature*) pObj)->minJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Quadrature_minJacobian_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class Quadrature1D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1D);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din2D);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din3D);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2D);
      std::cout << "Quadrature2D ptr: " << result << std::endl;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2Din3D);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature3D);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Integrator:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_integrator"
    return


  def createParameters(self, mesh):
    """
    Create manager for parameters.
    """
    # create shim for method 'createParameters'
    #embed{ void Integrator_createParameters(void* pObj, void* pMeshObj)
    try {
      const ALE::Obj<ALE::Mesh>* pMesh = (ALE::Obj<ALE::Mesh>*) pMeshObj;
      ((pylith::feassemble::Integrator*) pObj)->createParameters(*pMesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    Integrator_createParameters(self.thisptr, ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    # create shim for destructor
    #embed{ void Integrator_destructor(void* pObj)
    try {
      pylith::feassemble::Integrator* pQ =
        (pylith::feassemble::Integrator*) pObj;
      delete pQ;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, Integrator_destructor)


  property quadrature:
    def __set__(self, q):
      """
      Set quadrature.
      """
      # create shim for method 'quadrature'
      #embed{ void Integrator_quadrature_set(void* pObj, void* qObj)
      try {
        assert(0 != pObj);
        assert(0 != qObj);
        // :BUG: Cannot cast void* to Quadrature* because we lose what
        // type of Quadrature qObj is. 
        std::cout << "qObj ptr: " << qObj << std::endl;
        pylith::feassemble::Quadrature* quadrature =
          (pylith::feassemble::Quadrature*) qObj;
        ((pylith::feassemble::Integrator*) pObj)->quadrature(quadrature);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      Integrator_quadrature_set(self.thisptr, ptrFromHandle(q))


# ----------------------------------------------------------------------
cdef class IntegratorExplicit(Integrator):

  def __init__(self):
    """
    Constructor.
    """
    Integrator.__init__(self)
    return


  def integrateResidualLumped(residual, fieldInT, fieldInTmdt, coords):
    """
    Integrate residual term (b) for dynamic elasticity term for 3-D
    finite elemtnts.
    """
    print "WARNING: IntegratorExplicit::integrateResidualLumped not implemented."
    return


  def integrateResidual(residual, fieldInT, fieldInTmdt, coords):
    """
    Integrate residual term (b) for dynamic elasticity term for 3-D
    finite elemtnts.
    """
    print "WARNING: IntegratorExplicit::integrateResidual not implemented."
    return


  def integrateJacobianLumped(mat, fieldIn, coords):
    """
    Compute matrix (A) associated with operator.
    """
    print "WARNING: IntegratorExplicit::integrateJacobianLumped not implemented."
    return


  def integrateJacobianField(fieldOut, fieldIn, coords):
    """
    Compute field (A) associated with operator.
    """
    print "WARNING: IntegratorExplicit::integrateJacobian not implemented."
    return


# ----------------------------------------------------------------------
cdef class ExplicitElasticity(IntegratorExplicit):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ExplicitElasticity_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::ExplicitElasticity);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    IntegratorExplicit.__init__(self)
    self.thisptr = ExplicitElasticity_constructor()
    self.handle = self._createHandle()
    return


  def setupMatProp(self, mesh, cs, db):
    """
    Initialize integrator.

    @param mesh PETSc mesh
    @param cs Coordinate system associated with mesh vertices
    @param db Database of material properties
    """
    # create shim for method 'setupMatProp'
    #embed{ void ExplicitElasticity_setupMatProp(void* pObj, void* meshObj, void* csObj, void* dbObj)
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshObj;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csObj;
      spatialdata::spatialdb::SpatialDB* db =
        (spatialdata::spatialdb::SpatialDB*) dbObj;
      ((pylith::feassemble::ExplicitElasticity*) pObj)->setupMatProp(*mesh, cs, db);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::geocoords::CoordSys'."
    if not db.name == "spatialdata_spatialdb_SpatialDB":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::spatialdb::SpatialDB'."
    cdef void* meshObj
    meshObj = <void*> PyCObject_AsVoidPtr(mesh)
    ExplicitElasticity_setupMatProp(self.thisptr, meshObj,
                          ptrFromHandle(cs), ptrFromHandle(db))
    return


# End of file 
