# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/feassemble/Quadrature.hh"
#include "pylith/feassemble/Quadrature1D.hh"
#include "pylith/feassemble/Quadrature1Din2D.hh"
#include "pylith/feassemble/Quadrature1Din3D.hh"
#include "pylith/feassemble/Quadrature2D.hh"
#include "pylith/feassemble/Quadrature2Din3D.hh"
#include "pylith/feassemble/Quadrature3D.hh"

#include "pylith/feassemble/Integrator.hh"
#include "pylith/feassemble/IntegratorDynExplicit.hh"
#include "pylith/feassemble/DynExplicitElasticity.hh"
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
    ctypedef unsigned long size_t
    void* malloc(size_t size)
    void free(void* mem)

# ----------------------------------------------------------------------
cdef class Quadrature:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_Quadrature"
    return


  def initialize(self, basis, basisDeriv, quadPts, quadWts,
                 cellDim, numCorners, numQuadPts, spaceDim):
    """
    Set basis functions and their derivatives, and coordinates and
    weights of quadrature points.

    @param basis Basis functions evaluated at the quadrature points
    @param basisDeriv Basis function derivatives evaluated at quad pts
    @param quadPts Coordinates of quadrature points in reference cell
    @param quadWts Weights of quadrature points
    @param cellDim Dimension of reference cell
    @param numCorners Number of vertices in reference cell
    @param numQuadPts Number of quadrature points
    @param spaceDim Number of dimensions associated with cell vertices
    """
    # create shim for method 'initialize'
    #embed{ void Quadrature_initialize(void* pObj, double* basis, double* basisDeriv, double* quadPts, double* quadWts, int cellDim, int numCorners, int numQuadPts, int spaceDim)
    ((pylith::feassemble::Quadrature*) pObj)->initialize(basis, basisDeriv,
                                                         quadPts, quadWts,
                                                         cellDim, numCorners,
                                                         numQuadPts, spaceDim);
    #}embed

    import spatialdata.utils.simplearray

    # basis
    basis = spatialdata.utils.simplearray.objAsSimpleArray(basis)
    if not basis.isCompatible(nd=2, simpletype="double",
                              contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basis' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != basis.shape[0] or numCorners != basis.shape[1]:
      raise TypeError, \
            "Shape of argument 'basis' must be (numQuadPts, numCorners)."

    # basisDeriv
    basisDeriv = spatialdata.utils.simplearray.objAsSimpleArray(basisDeriv)
    if not basisDeriv.isCompatible(nd=3, simpletype="double",
                                   contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisDeriv' must be a contiguous, 3-D array " \
            "of type double."
    if numQuadPts != basisDeriv.shape[0] or \
           numCorners != basisDeriv.shape[1] or \
           cellDim != basisDeriv.shape[2]:
      raise TypeError, \
            "Shape of argument 'basisDeriv' must be (numQuadPts, " \
            "numCorners, cellDim)."

    # quadPts
    quadPts = spatialdata.utils.simplearray.objAsSimpleArray(quadPts)
    if not quadPts.isCompatible(nd=2, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadPts' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != quadPts.shape[0] or cellDim != quadPts.shape[1]:
      raise TypeError, \
            "Shape of argument 'quadPts' must be (numQuadPts, cellDim)."

    # quadWts
    quadWts = spatialdata.utils.simplearray.objAsSimpleArray(quadWts)
    if not quadWts.isCompatible(nd=1, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadWts' must be a contiguous, 1-D array " \
            "of type double."
    if numQuadPts != quadWts.shape[0]:
      raise TypeError, \
            "Shape of argument 'quadWts' must be (numQuadPts)."

    cdef double* basisCpp
    cdef double* basisDerivCpp
    cdef double* quadPtsCpp
    cdef double* quadWtsCpp
    basisCpp = <double*> PyCObject_AsVoidPtr(basis.data)
    basisDerivCpp = <double*> PyCObject_AsVoidPtr(basisDeriv.data)
    quadPtsCpp = <double*> PyCObject_AsVoidPtr(quadPts.data)
    quadWtsCpp = <double*> PyCObject_AsVoidPtr(quadWts.data)

    Quadrature_initialize(self.thisptr, basisCpp, basisDerivCpp,
                          quadPtsCpp, quadWtsCpp,
                          cellDim, numCorners,
                          numQuadPts, spaceDim)
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    # create shim for destructor
    #embed{ void Quadrature_destructor(void* pObj)
    pylith::feassemble::Quadrature* pQ =
      (pylith::feassemble::Quadrature*) pObj;
    delete pQ;
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, Quadrature_destructor)


  property minJacobian:
    def __set__(self, value):
      """Set minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ void Quadrature_minJacobian_set(void* pObj, double value)
      ((pylith::feassemble::Quadrature*) pObj)->minJacobian(value);
      #}embed
      Quadrature_minJacobian_set(self.thisptr, value)

    def __get__(self):
      """Get minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ double Quadrature_minJacobian_get(void* pObj)
      return ((pylith::feassemble::Quadrature*) pObj)->minJacobian();
      #}embed
      return Quadrature_minJacobian_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class Quadrature1D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1D_constructor()
    return (void*)(new pylith::feassemble::Quadrature1D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din2D_constructor()
    return (void*)(new pylith::feassemble::Quadrature1Din2D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din3D_constructor()
    return (void*)(new pylith::feassemble::Quadrature1Din3D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2D_constructor()
    return (void*)(new pylith::feassemble::Quadrature2D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2Din3D_constructor()
    return (void*)(new pylith::feassemble::Quadrature2Din3D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature3D_constructor()
    return (void*)(new pylith::feassemble::Quadrature3D);
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Integrator:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_integrator"
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    # create shim for destructor
    #embed{ void Integrator_destructor(void* pObj)
    pylith::feassemble::Integrator* pQ =
      (pylith::feassemble::Integrator*) pObj;
    delete pQ;
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, Integrator_destructor)


  property quadrature:
    def __set__(self, q):
      """Set quadrature."""
      # create shim for method 'quadrature'
      #embed{ void Integrator_quadrature_set(void* pObj, void* qObj)
      pylith::feassemble::Quadrature* quadrature =
        (pylith::feassemble::Quadrature*) qObj;
      ((pylith::feassemble::Integrator*) pObj)->quadrature(quadrature);
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      Integrator_quadrature_set(self.thisptr, ptrFromHandle(q))


# ----------------------------------------------------------------------
cdef class IntegratorDynExplicit(Integrator):

  def __init__(self):
    """
    Constructor.
    """
    Integrator.__init__(self)
    return

  def integrateResidual(residual, fieldInT, fieldInTmdt, coordinates):
    """
    Integrate residual term (b) for dynamic elasticity term for 3-D
    finite elemtnts.
    """
    print "WARNING: IntegratorDynExplicit::integrateResidual not implemented."
    return

  def integrateJacobianMat(mat, fieldIn, coordinates):
    """
    Compute matrix (A) associated with operator.
    """
    print "WARNING: IntegratorDynExplicit::integrateJacobian not implemented."
    return

  def integrateJacobianField(fieldOut, fieldIn, coordinates):
    """
    Compute field (A) associated with operator.
    """
    print "WARNING: IntegratorDynExplicit::integrateJacobian not implemented."
    return

  def initialize(self, mesh, cs, db):
    """
    Initialize integrator.

    @param mesh PETSc mesh
    @param cs Coordinate system associated with mesh vertices
    @param db Database of material properties
    """
    # create shim for method 'initialize'
    #embed{ void IntegratorDynExplicit_initialize(void* pObj, void* meshObj, void* csObj, void* dbObj)
    ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshObj;
    spatialdata::geocoords::CoordSys* cs =
      (spatialdata::geocoords::CoordSys*) csObj;
    spatialdata::spatialdb::SpatialDB* db =
      (spatialdata::spatialdb::SpatialDB*) dbObj;
    ((pylith::feassemble::IntegratorDynExplicit*) pObj)->initialize(*mesh, cs, db);
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::geocoords::CoordSys'."
    if not db.name == "spatialdata_spatialdb_SpatialDB":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::spatialdb::SpatialDB'."
    cdef void* meshObj
    meshObj = <void*> PyCObject_AsVoidPtr(mesh)
    IntegratorDynExplicit_initialize(self.thisptr, meshObj,
                          ptrFromHandle(cs), ptrFromHandle(db))
    return


# ----------------------------------------------------------------------
cdef class DynExplicitElasticity(IntegratorDynExplicit):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* DynExplicitElasticity_constructor()
    return (void*)(new pylith::feassemble::DynExplicitElasticity);
    #}embed

    IntegratorDynExplicit.__init__(self)
    self.thisptr = DynExplicitElasticity_constructor()
    self.handle = self._createHandle()
    return


# End of file 
