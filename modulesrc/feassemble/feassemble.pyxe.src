# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/feassemble/Quadrature.hh"
#include "pylith/feassemble/Quadrature1D.hh"
#include "pylith/feassemble/Quadrature1Din2D.hh"
#include "pylith/feassemble/Quadrature1Din3D.hh"
#include "pylith/feassemble/Quadrature2D.hh"
#include "pylith/feassemble/Quadrature2Din3D.hh"
#include "pylith/feassemble/Quadrature3D.hh"

#include "pylith/feassemble/Integrator.hh"
#include "pylith/feassemble/IntegratorExplicit.hh"
#include "pylith/feassemble/ExplicitElasticity.hh"

#include "pylith/utils/petscfwd.h"

#include <assert.h>
#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
    ctypedef unsigned long size_t
    void* malloc(size_t size)
    void free(void* mem)

cdef void Quadrature_destructor(void* obj):
  """
  Destroy Quadrature object.
  """
  # create shim for destructor
  #embed{ void Quadrature_destructor_cpp(void* objVptr)
  pylith::feassemble::Quadrature* pQ =
    (pylith::feassemble::Quadrature*) objVptr;
  delete pQ;
  #}embed
  Quadrature_destructor_cpp(obj)
  return

cdef void Integrator_destructor(void* obj):
  """
  Destroy Integrator object.
  """
  # create shim for destructor
  #embed{ void Integrator_destructor_cpp(void* objVptr)
  pylith::feassemble::Integrator* pQ =
    (pylith::feassemble::Integrator*) objVptr;
  delete pQ;
  #}embed
  Integrator_destructor_cpp(obj)
  return


# ----------------------------------------------------------------------
cdef class Quadrature:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_Quadrature"
    return


  def initialize(self,
                 basisVert, basisDerivVert,
                 basisQuad, basisDerivQuad,
                 quadPts, quadWts,
                 cellDim, numBasis, numQuadPts, spaceDim):
    """
    Set basis functions and their derivatives, and coordinates and
    weights of quadrature points.

    @param basisVert Basis functions evaluated at the vertices
    @param basisDerivVert Basis function derivatives evaluated at vertices
    @param basisQuad Basis functions evaluated at the quadrature points
    @param basisDerivQuad Basis function derivatives evaluated at quad pts
    @param quadPts Coordinates of quadrature points in reference cell
    @param quadWts Weights of quadrature points
    @param cellDim Dimension of reference cell
    @param numBasis Number of vertices in reference cell
    @param numQuadPts Number of quadrature points
    @param spaceDim Number of dimensions associated with cell vertices
    """
    # create shim for method 'initialize'
    #embed{ void Quadrature_initialize(void* objVptr, double* basisVert, double* basisDerivVert, double* basisQuad, double* basisDerivQuad, double* quadPts, double* quadWts, int cellDim, int numBasis, int numQuadPts, int spaceDim)
    try {
      ((pylith::feassemble::Quadrature*) objVptr)->initialize(
                                         basisVert, basisDerivVert,
                                         basisQuad, basisDerivQuad,
                                         quadPts, quadWts,
                                         cellDim, numBasis,
                                         numQuadPts, spaceDim);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    import spatialdata.utils.simplearray

    numVertices = numBasis

    # basisVert
    basisVert = spatialdata.utils.simplearray.objAsSimpleArray(basisVert)
    if not basisVert.isCompatible(nd=2, simpletype="double",
                                  contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisVert' must be a contiguous, 2-D array " \
            "of type double."
    if numVertices != basisVert.shape[0] or numBasis != basisVert.shape[1]:
      raise TypeError, \
            "Shape of argument 'basisVert' must be (numVertices, numBasis)."

    # basisDerivVert
    basisDerivVert = spatialdata.utils.simplearray.objAsSimpleArray(basisDerivVert)
    if not basisDerivVert.isCompatible(nd=3, simpletype="double",
                                       contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisDerivVert' must be a contiguous, 3-D array " \
            "of type double."
    if numVertices != basisDerivVert.shape[0] or \
           numBasis != basisDerivVert.shape[1] or \
           cellDim != basisDerivVert.shape[2]:
      raise TypeError, \
            "Shape of argument 'basisDerivVert' must be (numVertices, " \
            "numBasis, cellDim)."

    # basisQuad
    basisQuad = spatialdata.utils.simplearray.objAsSimpleArray(basisQuad)
    if not basisQuad.isCompatible(nd=2, simpletype="double",
                                  contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisQuad' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != basisQuad.shape[0] or numBasis != basisQuad.shape[1]:
      raise TypeError, \
            "Shape of argument 'basisQuad' must be (numQuadPts, numBasis)."

    # basisDerivQuad
    basisDerivQuad = spatialdata.utils.simplearray.objAsSimpleArray(basisDerivQuad)
    if not basisDerivQuad.isCompatible(nd=3, simpletype="double",
                                       contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisDerivQuad' must be a contiguous, 3-D array " \
            "of type double."
    if numQuadPts != basisDerivQuad.shape[0] or \
           numBasis != basisDerivQuad.shape[1] or \
           cellDim != basisDerivQuad.shape[2]:
      raise TypeError, \
            "Shape of argument 'basisDerivQuad' must be (numQuadPts, " \
            "numBasis, cellDim)."

    # quadPts
    quadPts = spatialdata.utils.simplearray.objAsSimpleArray(quadPts)
    if not quadPts.isCompatible(nd=2, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadPts' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != quadPts.shape[0] or cellDim != quadPts.shape[1]:
      raise TypeError, \
            "Shape of argument 'quadPts' must be (numQuadPts, cellDim)."

    # quadWts
    quadWts = spatialdata.utils.simplearray.objAsSimpleArray(quadWts)
    if not quadWts.isCompatible(nd=1, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadWts' must be a contiguous, 1-D array " \
            "of type double."
    if numQuadPts != quadWts.shape[0]:
      raise TypeError, \
            "Shape of argument 'quadWts' must be (numQuadPts)."

    cdef double* basisCppVert
    cdef double* basisDerivCppVert
    cdef double* basisCppQuad
    cdef double* basisDerivCppQuad
    cdef double* quadPtsCpp
    cdef double* quadWtsCpp
    basisCppVert = <double*> PyCObject_AsVoidPtr(basisVert.data)
    basisDerivCppVert = <double*> PyCObject_AsVoidPtr(basisDerivVert.data)
    basisCppQuad = <double*> PyCObject_AsVoidPtr(basisQuad.data)
    basisDerivCppQuad = <double*> PyCObject_AsVoidPtr(basisDerivQuad.data)
    quadPtsCpp = <double*> PyCObject_AsVoidPtr(quadPts.data)
    quadWtsCpp = <double*> PyCObject_AsVoidPtr(quadWts.data)

    Quadrature_initialize(self.thisptr,
                          basisCppVert, basisDerivCppVert,
                          basisCppQuad, basisDerivCppQuad,
                          quadPtsCpp, quadWtsCpp,
                          cellDim, numBasis,
                          numQuadPts, spaceDim)
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, Quadrature_destructor)


  property minJacobian:
    def __set__(self, value):
      """Set minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ void Quadrature_minJacobian_set(void* objVptr, double value)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Quadrature*) objVptr)->minJacobian(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Quadrature_minJacobian_set(self.thisptr, value)

    def __get__(self):
      """Get minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ double Quadrature_minJacobian_get(void* objVptr)
      double result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::feassemble::Quadrature*) objVptr)->minJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Quadrature_minJacobian_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class Quadrature1D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2Din3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Integrator:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_integrator"
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, Integrator_destructor)


  property quadrature:
    def __set__(self, q):
      """
      Set quadrature.
      """
      # create shim for method 'quadrature'
      #embed{ void Integrator_quadrature_set(void* objVptr, void* qVptr)
      try {
        assert(0 != objVptr);
        pylith::feassemble::Quadrature* quadrature =
          (pylith::feassemble::Quadrature*) qVptr;
        ((pylith::feassemble::Integrator*) objVptr)->quadrature(quadrature);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      Integrator_quadrature_set(self.thisptr, ptrFromHandle(q))


# ----------------------------------------------------------------------
cdef class IntegratorExplicit(Integrator):

  def __init__(self):
    """
    Constructor.
    """
    Integrator.__init__(self)
    return


  def integrateConstant(self, fieldOut, fieldInT, fieldInTmdt, mesh):
    """
    Integrate constant term (b) for dynamic elasticity term for 3-D
    finite elements.
    """
    # create shim for method 'integrateConstant'
    #embed{ void IntegratorExplicit_integrateConstant(void* objVptr, void* fieldOutVptr, void* fieldInTVptr, void* fieldInTmdtVptr, void* meshVptr)
    typedef ALE::Mesh Mesh;
    typedef ALE::Mesh::real_section_type real_section_type;

    try {
      assert(0 != objVptr);
      assert(0 != fieldOutVptr);
      assert(0 != fieldInTVptr);
      assert(0 != fieldInTmdtVptr);
      assert(0 != meshVptr);
      ALE::Obj<Mesh>* mesh =
        (ALE::Obj<Mesh>*) meshVptr;
      ALE::Obj<real_section_type>* fieldOut =
        (ALE::Obj<real_section_type>*) fieldOutVptr;
      ALE::Obj<real_section_type>* fieldInT =
        (ALE::Obj<real_section_type>*) fieldInTVptr;
      ALE::Obj<real_section_type>* fieldInTmdt =
        (ALE::Obj<real_section_type>*) fieldInTmdtVptr;
      ((pylith::feassemble::IntegratorExplicit*) objVptr)->integrateConstant(
                *fieldOut, *fieldInT, *fieldInTmdt, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef void* fieldOutVptr
    cdef void* fieldInTVptr
    cdef void* fieldInTmdtVptr
    fieldOutVptr = PyCObject_AsVoidPtr(fieldOut)
    fieldInTVptr = PyCObject_AsVoidPtr(fieldInT)
    fieldInTmdtVptr = PyCObject_AsVoidPtr(fieldInTmdt)
    IntegratorExplicit_integrateConstant(self.thisptr, 
                                         fieldOutVptr, fieldInTVptr,
                                         fieldInTmdtVptr,
                                         ptrFromHandle(mesh))
    return


  def integrateJacobian(self, mat, fieldIn, mesh):
    """
    Compute matrix (A) associated with operator.
    """
    # create shim for method 'integrateJacobian'
    #embed{ void IntegratorExplicit_integrateJacobian(void* objVptr, void* matVptr, void* fieldInVptr, void* meshVptr)
    typedef ALE::Mesh Mesh;
    typedef ALE::Mesh::real_section_type real_section_type;

    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldInVptr);
      assert(0 != meshVptr);
      ALE::Obj<Mesh>* mesh =
        (ALE::Obj<Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      ALE::Obj<real_section_type>* fieldIn =
        (ALE::Obj<real_section_type>*) fieldInVptr;
      ((pylith::feassemble::IntegratorExplicit*) objVptr)->integrateJacobian(
                mat, *fieldIn, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef void* matVptr
    cdef void* fieldInVptr
    matVptr = PyCObject_AsVoidPtr(mat)
    fieldInVptr = PyCObject_AsVoidPtr(fieldIn)
    IntegratorExplicit_integrateJacobian(self.thisptr, matVptr, fieldInVptr,
                                         ptrFromHandle(mesh))
    return


  property timeStep:
    def __set__(self, dt):
      """
      Set timeStep.
      """
      # create shim for method 'timeStep'
      #embed{ void IntegratorExplicit_timeStep_set(void* objVptr, double dt)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::IntegratorExplicit*) objVptr)->timeStep(dt);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      IntegratorExplicit_timeStep_set(self.thisptr, dt)


# ----------------------------------------------------------------------
cdef class ExplicitElasticity(IntegratorExplicit):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ExplicitElasticity_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::ExplicitElasticity);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    IntegratorExplicit.__init__(self)
    self.thisptr = ExplicitElasticity_constructor()
    self.handle = self._createHandle()
    return


  property material:
    def __set__(self, m):
      """
      Set material.
      """
      # create shim for method 'material'
      #embed{ void ExplicitElasticity_material_set(void* objVptr, void* mVptr)
      try {
        assert(0 != objVptr);
        pylith::materials::ElasticMaterial* material =
          (pylith::materials::ElasticMaterial*) mVptr;
        ((pylith::feassemble::ExplicitElasticity*) objVptr)->material(material);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not m.name == "pylith_materials_ElasticMaterial":
        raise TypeError, \
              "Argument must be extension module type 'ElasticMaterial'."
      ExplicitElasticity_material_set(self.thisptr, ptrFromHandle(m))


# End of file 
