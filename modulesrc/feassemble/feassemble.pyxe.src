# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/feassemble/CellGeometry.hh"
#include "pylith/feassemble/GeometryPoint1D.hh"
#include "pylith/feassemble/GeometryPoint2D.hh"
#include "pylith/feassemble/GeometryPoint3D.hh"
#include "pylith/feassemble/GeometryLine1D.hh"
#include "pylith/feassemble/GeometryLine2D.hh"
#include "pylith/feassemble/GeometryLine3D.hh"
#include "pylith/feassemble/GeometryTri2D.hh"
#include "pylith/feassemble/GeometryTri3D.hh"
#include "pylith/feassemble/GeometryQuad2D.hh"
#include "pylith/feassemble/GeometryQuad3D.hh"
#include "pylith/feassemble/GeometryTet3D.hh"
#include "pylith/feassemble/GeometryHex3D.hh"

#include "pylith/feassemble/Quadrature.hh"
#include "pylith/feassemble/Quadrature0D.hh"
#include "pylith/feassemble/Quadrature1D.hh"
#include "pylith/feassemble/Quadrature1Din2D.hh"
#include "pylith/feassemble/Quadrature1Din3D.hh"
#include "pylith/feassemble/Quadrature2D.hh"
#include "pylith/feassemble/Quadrature2Din3D.hh"
#include "pylith/feassemble/Quadrature3D.hh"

#include "pylith/feassemble/Integrator.hh"
#include "pylith/feassemble/IntegratorElasticity.hh"
#include "pylith/feassemble/ElasticityExplicit.hh"
#include "pylith/feassemble/ElasticityImplicit.hh"

#include "pylith/feassemble/Constraint.hh"

#include "pylith/utils/petscfwd.h"

#include <assert.h>
#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
    ctypedef unsigned long size_t
    void* malloc(size_t size)
    void free(void* mem)

# ----------------------------------------------------------------------
cdef void CellGeometry_destructor(void* obj):
  """
  Destroy CellGeometry object.
  """
  # create shim for destructor
  #embed{ void CellGeometry_destructor_cpp(void* objVptr)
  pylith::feassemble::CellGeometry* pQ =
    (pylith::feassemble::CellGeometry*) objVptr;
  delete pQ;
  #}embed
  CellGeometry_destructor_cpp(obj)
  return

cdef class CellGeometry:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_CellGeometry"
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, CellGeometry_destructor)


# ----------------------------------------------------------------------
cdef class GeometryPoint1D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryPoint1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryPoint1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryPoint1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryPoint2D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryPoint2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryPoint2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryPoint2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryPoint3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryPoint3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryPoint3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryPoint3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryLine1D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryLine1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryLine1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryLine1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryLine2D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryLine2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryLine2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryLine2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryLine3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryLine3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryLine3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryLine3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryTri2D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryTri2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryTri2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryTri2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryTri3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryTri3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryTri3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryTri3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryQuad2D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryQuad2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryQuad2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryQuad2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryQuad3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryQuad3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryQuad3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryQuad3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryTet3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryTet3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryTet3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryTet3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GeometryHex3D(CellGeometry):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* GeometryHex3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::GeometryHex3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    CellGeometry.__init__(self)
    self.thisptr = GeometryHex3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef void Quadrature_destructor(void* obj):
  """
  Destroy Quadrature object.
  """
  # create shim for destructor
  #embed{ void Quadrature_destructor_cpp(void* objVptr)
  pylith::feassemble::Quadrature* pQ =
    (pylith::feassemble::Quadrature*) objVptr;
  delete pQ;
  #}embed
  Quadrature_destructor_cpp(obj)
  return

cdef class Quadrature:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_Quadrature"
    return


  def initialize(self,
                 basis, basisDeriv,
                 quadPts, quadWts,
                 cellDim, numBasis, numQuadPts, spaceDim):
    """
    Set basis functions and their derivatives, and coordinates and
    weights of quadrature points.

    @param basis Basis functions evaluated at the quadrature points
    @param basisDeriv Basis function derivatives evaluated at quad pts
    @param quadPts Coordinates of quadrature points in reference cell
    @param quadWts Weights of quadrature points
    @param cellDim Dimension of reference cell
    @param numBasis Number of basis functions
    @param numQuadPts Number of quadrature points
    @param spaceDim Number of dimensions associated with cell vertices
    """
    # create shim for method 'initialize'
    #embed{ void Quadrature_initialize(void* objVptr, double* basis, double* basisDeriv, double* quadPts, double* quadWts, int cellDim, int numBasis, int numQuadPts, int spaceDim)
    try {
      ((pylith::feassemble::Quadrature*) objVptr)->initialize(
                                         basis, basisDeriv,
                                         quadPts, quadWts,
                                         cellDim, numBasis,
                                         numQuadPts, spaceDim);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    import spatialdata.utils.simplearray

    # basis
    basis = spatialdata.utils.simplearray.objAsSimpleArray(basis)
    if not basis.isCompatible(nd=2, simpletype="double",
                              contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basis' must be a contiguous, 2-D array " \
            "of type double."
    if numQuadPts != basis.shape[0] or numBasis != basis.shape[1]:
      raise TypeError, \
            "Shape of argument 'basis' must be (numQuadPts, numBasis)."

    # basisDeriv
    basisDeriv = spatialdata.utils.simplearray.objAsSimpleArray(basisDeriv)
    if not basisDeriv.isCompatible(nd=3, simpletype="double",
                                   contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'basisDeriv' must be a contiguous, 3-D array " \
            "of type double."
    if cellDim > 0:
      if numQuadPts != basisDeriv.shape[0] or \
             numBasis != basisDeriv.shape[1] or \
             cellDim != basisDeriv.shape[2]:
        raise TypeError, \
              "Shape of argument 'basisDeriv' must be (numQuadPts, " \
              "numBasis, cellDim)."
    else:
      if 1 != basisDeriv.shape[0] or \
             1 != basisDeriv.shape[1] or \
             1 != basisDeriv.shape[2]:
        raise TypeError, \
              "Shape of argument 'basisDeriv' must be (1, 1, 1) for 0-D cell."

    # quadPts
    quadPts = spatialdata.utils.simplearray.objAsSimpleArray(quadPts)
    if not quadPts.isCompatible(nd=2, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadPts' must be a contiguous, 2-D array " \
            "of type double."
    if cellDim > 0:
      if numQuadPts != quadPts.shape[0] or cellDim != quadPts.shape[1]:
        raise TypeError, \
              "Shape of argument 'quadPts' must be (numQuadPts, cellDim)."
    else:
      if 1 != quadPts.shape[0] or 1 != quadPts.shape[1]:
        raise TypeError, \
              "Shape of argument 'quadPts' must be (1, 1) for 0-D cell."

    # quadWts
    quadWts = spatialdata.utils.simplearray.objAsSimpleArray(quadWts)
    if not quadWts.isCompatible(nd=1, simpletype="double",
                                contiguous=True, notswapped=True):
      raise TypeError, \
            "Argument 'quadWts' must be a contiguous, 1-D array " \
            "of type double."
    if numQuadPts != quadWts.shape[0]:
      raise TypeError, \
            "Shape of argument 'quadWts' must be (numQuadPts)."

    cdef double* basisCpp
    cdef double* basisDerivCpp
    cdef double* quadPtsCpp
    cdef double* quadWtsCpp
    basisCpp = <double*> PyCObject_AsVoidPtr(basis.data)
    basisDerivCpp = <double*> PyCObject_AsVoidPtr(basisDeriv.data)
    quadPtsCpp = <double*> PyCObject_AsVoidPtr(quadPts.data)
    quadWtsCpp = <double*> PyCObject_AsVoidPtr(quadWts.data)

    Quadrature_initialize(self.thisptr,
                          basisCpp, basisDerivCpp,
                          quadPtsCpp, quadWtsCpp,
                          cellDim, numBasis,
                          numQuadPts, spaceDim)
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, Quadrature_destructor)


  property minJacobian:
    def __set__(self, value):
      """Set minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ void Quadrature_minJacobian_set(void* objVptr, double value)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Quadrature*) objVptr)->minJacobian(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Quadrature_minJacobian_set(self.thisptr, value)

    def __get__(self):
      """Get minimum allowable Jacobian."""
      # create shim for method 'minJacobian'
      #embed{ double Quadrature_minJacobian_get(void* objVptr)
      double result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::feassemble::Quadrature*) objVptr)->minJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Quadrature_minJacobian_get(self.thisptr)


  property checkConditioning:
    def __set__(self, flag):
      """Set minimum allowable Jacobian."""
      # create shim for method 'checkConditioning'
      #embed{ void Quadrature_checkConditioning_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Quadrature*) objVptr)->checkConditioning(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Quadrature_checkConditioning_set(self.thisptr, flag)

    def __get__(self):
      """Get minimum allowable Jacobian."""
      # create shim for method 'checkConditioning'
      #embed{ int Quadrature_checkConditioning_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::feassemble::Quadrature*) objVptr)->checkConditioning();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Quadrature_checkConditioning_get(self.thisptr)


  property refGeometry:
    def __set__(self, value):
      """
      Set geometry associated with reference cell.
      """
      # create shim for method 'refGeometry'
      #embed{ void Quadrature_refGeometry_set(void* objVptr, void* geomVptr)
      try {
        assert(0 != objVptr);
        assert(0 != geomVptr);
        pylith::feassemble::CellGeometry* geom =
          (pylith::feassemble::CellGeometry*) geomVptr;
        ((pylith::feassemble::Quadrature*) objVptr)->refGeometry(geom);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "pylith_feassemble_CellGeometry":
        raise TypeError, \
              "Argument must be extension module type " \
              "'pylith::feassemble::CellGeometry'."
      Quadrature_refGeometry_set(self.thisptr, ptrFromHandle(value))


# ----------------------------------------------------------------------
cdef class Quadrature0D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature0D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature0D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature0D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature1Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature1Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature1Din3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature1Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature2Din3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature2Din3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature2Din3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature2Din3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class Quadrature3D(Quadrature):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Quadrature3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::Quadrature3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Quadrature.__init__(self)
    self.thisptr = Quadrature3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef void Integrator_destructor(void* obj):
  """
  Destroy Integrator object.
  """
  # create shim for destructor
  #embed{ void Integrator_destructor_cpp(void* objVptr)
  pylith::feassemble::Integrator* pQ =
    (pylith::feassemble::Integrator*) objVptr;
  delete pQ;
  #}embed
  Integrator_destructor_cpp(obj)
  return


cdef class Integrator:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_integrator"
    return


  def integrateResidual(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator.
    """
    # create shim for method 'integrateResidual'
    #embed{ void Integrator_integrateResidual(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::feassemble::Integrator*) objVptr)->integrateResidual(*residual,
                                                            t, fields, *mesh,
							    cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    Integrator_integrateResidual(self.thisptr, 
                                 PyCObject_AsVoidPtr(residual),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh),
				 ptrFromHandle(cs))
    return


  def integrateJacobian(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with operator.
    """
    # create shim for method 'integrateJacobian'
    #embed{ void Integrator_integrateJacobian(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::feassemble::Integrator*) objVptr)->integrateJacobian(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if fields.name != "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument 'fields' must be extension module type 'FieldsManager'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Integrator_integrateJacobian(self.thisptr,
                                 PyCObject_AsVoidPtr(mat),
                                 t,
                                 ptrFromHandle(fields),
                                 ptrFromHandle(mesh))
    return


  def integrateResidualAssembled(self, residual, t, fields, mesh, cs):
    """
    Integrate contributions to residual term (r) for operator that do
    not require assembly over cells, vertices, or processors.
    """
    # create shim for method 'integrateResidualAssembled'
    #embed{ void Integrator_integrateResidualAssembled(void* objVptr, void* residualVptr, double t, void* fieldsVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != objVptr);
      assert(0 != residualVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::real_section_type>* residual =
        (ALE::Obj<pylith::real_section_type>*) residualVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      ((pylith::feassemble::Integrator*) objVptr)->integrateResidualAssembled(*residual,
                                                            t, fields, *mesh,
							    cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    Integrator_integrateResidualAssembled(self.thisptr, 
                                          PyCObject_AsVoidPtr(residual),
                                          t,
                                          ptrFromHandle(fields),
                                          ptrFromHandle(mesh),
                                          ptrFromHandle(cs))
    return


  def integrateJacobianAssembled(self, mat, t, fields, mesh):
    """
    Compute contributions to Jacobian matrix (A) associated with
    operator that do not require assembly over cells, vertices, or
    processors.
    """
    # create shim for method 'integrateJacobianAssembled'
    #embed{ void Integrator_integrateJacobianAssembled(void* objVptr, void* matVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != matVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      PetscMat* mat = (PetscMat*) matVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ((pylith::feassemble::Integrator*) objVptr)->integrateJacobianAssembled(
                                                        mat, t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if fields.name != "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument 'fields' must be extension module type 'FieldsManager'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Integrator_integrateJacobianAssembled(self.thisptr,
                                          PyCObject_AsVoidPtr(mat),
                                          t,
                                          ptrFromHandle(fields),
                                          ptrFromHandle(mesh))
    return


  def updateState(self, t, fields, mesh):
    """
    Update state variables as needed.
    """
    # create shim for method 'updateState'
    #embed{ void Integrator_updateState(void* objVptr, double t, void* fieldsVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldsVptr);
      assert(0 != meshVptr);
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::feassemble::Integrator*) objVptr)->updateState(t, fields, *mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if fields.name != "pylith_topology_FieldsManager":
      raise TypeError, \
            "Argument 'fields' must be extension module type 'FieldsManager'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Integrator_updateState(self.thisptr,
                           t,
                           ptrFromHandle(fields),
                           ptrFromHandle(mesh))
    return


  def verifyConfiguration(self, mesh):
    """
    Verify compatibility of configuration settings.
    """
    # create shim for method 'verifyConfiguration'
    #embed{ void Integrator_verifyConfiguration(void* objVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh =
        (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::feassemble::Integrator*) objVptr)->verifyConfiguration(*mesh);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    Integrator_verifyConfiguration(self.thisptr,
                                   ptrFromHandle(mesh))
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, Integrator_destructor)


  property quadrature:
    def __set__(self, q):
      """
      Set quadrature.
      """
      # create shim for method 'quadrature'
      #embed{ void Integrator_quadrature_set(void* objVptr, void* qVptr)
      try {
        assert(0 != objVptr);
        assert(0 != qVptr);
        pylith::feassemble::Quadrature* quadrature =
          (pylith::feassemble::Quadrature*) qVptr;
        ((pylith::feassemble::Integrator*) objVptr)->quadrature(quadrature);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not q.name == "pylith_feassemble_Quadrature":
        raise TypeError, \
              "Argument must be extension module type 'Quadrature'."
      Integrator_quadrature_set(self.thisptr, ptrFromHandle(q))


  property normalizer:
    def __set__(self, value):
      """
      Set nondimensionalizer.
      """
      # create shim for method 'normalizer'
      #embed{ void Integrator_normalizer_set(void* objVptr, void* dimVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dimVptr);
        spatialdata::units::Nondimensional* dim =
          (spatialdata::units::Nondimensional*) dimVptr;
        ((pylith::feassemble::Integrator*) objVptr)->normalizer(*dim);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_units_Nondimensional":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::units::Nondimensional'."
      Integrator_normalizer_set(self.thisptr, ptrFromHandle(value))


  property gravityField:
    def __set__(self, g):
      """
      Set gravity field.
      """
      # create shim for method 'gravityField'
      #embed{ void Integrator_gravityField_set(void* objVptr, void* gVptr)
      try {
        assert(0 != objVptr);
        spatialdata::spatialdb::GravityField* gravityField =
          (spatialdata::spatialdb::GravityField*) gVptr;
        ((pylith::feassemble::Integrator*) objVptr)->gravityField(gravityField);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not g.name == "spatialdata_spatialdb_SpatialDB":
        raise TypeError, \
              "Argument must be extension module type 'SpatialDB'."
      if None == g:
        Integrator_gravityField_set(self.thisptr, NULL)
      else:
        Integrator_gravityField_set(self.thisptr, ptrFromHandle(g))


  property timeStep:
    def __set__(self, dt):
      """
      Set timeStep.
      """
      # create shim for method 'timeStep'
      #embed{ void Integrator_timeStep_set(void* objVptr, double dt)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Integrator*) objVptr)->timeStep(dt);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Integrator_timeStep_set(self.thisptr, dt)


  property stableTimeStep:
    def __get__(self):
      """
      Get stable time step.
      """
      # create shim for method 'stableTimeStep'
      #embed{ double Integrator_stableTimeStep_get(void* objVptr)
      double result = 0.0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::feassemble::Integrator*) objVptr)->stableTimeStep();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Integrator_stableTimeStep_get(self.thisptr)


  property needNewJacobian:
    def __get__(self):
      """
      Set timeStep.
      """
      # create shim for method 'needNewJacobian'
      #embed{ int Integrator_needNewJacobian_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result =
          ((pylith::feassemble::Integrator*) objVptr)->needNewJacobian();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Integrator_needNewJacobian_get(self.thisptr)


  property useSolnIncr:
    def __set__(self, flag):
      """
      Set solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void Integrator_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Integrator*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Integrator_useSolnIncr_set(self.thisptr, flag)


# ----------------------------------------------------------------------
cdef class IntegratorElasticity(Integrator):

  def __init__(self):
    """
    Constructor.
    """
    Integrator.__init__(self)
    return


  def cellField(self, name, mesh, fields=None):
    """
    Get cell field.
    """
    # create shim for method 'cellField'
    #embed{ void* IntegratorElasticity_cellField(void* objVptr, int* fieldPtr, char* name, void* meshVptr, void* fieldsVptr)
    void* result = 0;
    try {
      assert(0 != objVptr);
      assert(0 != fieldPtr);
      assert(0 != name);
      assert(0 != meshVptr);
      pylith::feassemble::IntegratorElasticity* integrator = (pylith::feassemble::IntegratorElasticity*) objVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      pylith::topology::FieldsManager* fields =
        (pylith::topology::FieldsManager*) fieldsVptr;
      pylith::VectorFieldEnum fieldType;
      const ALE::Obj<pylith::real_section_type>& field =
        integrator->cellField(&fieldType, name, *mesh, fields);
      *fieldPtr = fieldType;
      result = (void*) &field;
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    if None != fields:
      if not fields.name == "pylith_topology_FieldsManager":
        raise TypeError, \
              "Argument 'fields' must be extension module type " \
              "'pylith::topology::FieldsManager'."
    cdef void* ptr
    cdef int fieldType
    fieldType = 3
    if None != fields:
      ptr = IntegratorElasticity_cellField(self.thisptr, &fieldType, name,
                                           ptrFromHandle(mesh),
                                           ptrFromHandle(fields))
    else:
      ptr = IntegratorElasticity_cellField(self.thisptr, &fieldType, name,
                                           ptrFromHandle(mesh), NULL)
    return (PyCObject_FromVoidPtr(ptr, NULL), fieldType)


  property material:
    def __set__(self, m):
      """
      Set material.
      """
      # create shim for method 'material'
      #embed{ void IntegratorElasticity_material_set(void* objVptr, void* mVptr)
      try {
        assert(0 != objVptr);
        pylith::materials::ElasticMaterial* material =
          (pylith::materials::ElasticMaterial*) mVptr;
        ((pylith::feassemble::IntegratorElasticity*) objVptr)->material(material);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not m.name == "pylith_materials_ElasticMaterial":
        raise TypeError, \
              "Argument must be extension module type 'ElasticMaterial'."
      IntegratorElasticity_material_set(self.thisptr, ptrFromHandle(m))


# ----------------------------------------------------------------------
cdef class ElasticityExplicit(IntegratorElasticity):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticityExplicit_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::ElasticityExplicit);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Integrator.__init__(self)
    self.thisptr = ElasticityExplicit_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class ElasticityImplicit(IntegratorElasticity):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticityImplicit_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::feassemble::ElasticityImplicit);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    Integrator.__init__(self)
    self.thisptr = ElasticityImplicit_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef void Constraint_destructor(void* obj):
  """
  Destroy Constraint object.
  """
  # create shim for destructor
  #embed{ void Constraint_destructor_cpp(void* objVptr)
  pylith::feassemble::Constraint* pQ =
    (pylith::feassemble::Constraint*) objVptr;
  delete pQ;
  #}embed
  Constraint_destructor_cpp(obj)
  return


cdef class Constraint:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_feassemble_constraint"
    return


  def setConstraintSizes(self, field, mesh):
    """
    Set number of degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraintSizes'
    #embed{ void Constraint_setConstraintSizes(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::feassemble::Constraint*) objVptr)->setConstraintSizes(*field, *mesh);
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    Constraint_setConstraintSizes(self.thisptr, PyCObject_AsVoidPtr(field),
                                  ptrFromHandle(mesh))
    return


  def setConstraints(self, field, mesh):
    """
    Set which degrees of freedom that are constrained at points in field.
    """
    # create shim for method 'setConstraints'
    #embed{ void Constraint_setConstraints(void* objVptr, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::feassemble::Constraint*) objVptr)->setConstraints(*field, *mesh);
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    Constraint_setConstraints(self.thisptr, PyCObject_AsVoidPtr(field), ptrFromHandle(mesh))
    return


  def setField(self, t, field, mesh):
    """
    Set values in field.
    """
    # create shim for method 'setField'
    #embed{ void Constraint_setField(void* objVptr, double t, void* fieldVptr, void* meshVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      assert(0 != meshVptr);
      ALE::Obj<pylith::real_section_type>* field = (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ((pylith::feassemble::Constraint*) objVptr)->setField(t, *field, *mesh);
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type " \
            "'pylith::topology::Mesh'."
    Constraint_setField(self.thisptr, t, PyCObject_AsVoidPtr(field),
                        ptrFromHandle(mesh))
    return


  property normalizer:
    def __set__(self, value):
      """
      Set nondimensionalizer.
      """
      # create shim for method 'normalizer'
      #embed{ void Constraint_normalizer_set(void* objVptr, void* dimVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dimVptr);
        spatialdata::units::Nondimensional* dim =
          (spatialdata::units::Nondimensional*) dimVptr;
        ((pylith::feassemble::Constraint*) objVptr)->normalizer(*dim);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_units_Nondimensional":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::units::Nondimensional'."
      Constraint_normalizer_set(self.thisptr, ptrFromHandle(value))


  property useSolnIncr:
    def __set__(self, flag):
      """
      Set use solution increment flag.
      """
      # create shim for method 'useSolnIncr'
      #embed{ void Constraint_useSolnIncr_set(void* objVptr, int flag)
      try {
        assert(0 != objVptr);
        ((pylith::feassemble::Constraint*) objVptr)->useSolnIncr(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Constraint_useSolnIncr_set(self.thisptr, flag)


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, Constraint_destructor)


# End of file 
