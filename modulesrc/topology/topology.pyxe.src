# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/topology/FieldsManager.hh"
#include "pylith/topology/Distributor.hh"
#include "pylith/topology/MeshOps.hh"
#include "pylith/topology/MeshRefiner.hh"
#include "pylith/topology/RefineUniform.hh"
#include "pylith/utils/sievetypes.hh"
#include "pylith/utils/petscfwd.h"
#include <petscmesh.hh>
 
#include <stdexcept>
#include <Python.h>
#include <assert.h>
#include <mpi.h>
#include "mpi/pympi.h"
#}header

# ----------------------------------------------------------------------

cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

cdef void MeshPtr_destructor(void* obj):
  """
  Destroy Petsc Mesh.
  """
  #embed{ void MeshPtr_destructor_cpp(void* objVptr)
  ALE::Obj<pylith::Mesh>* pMesh = (ALE::Obj<pylith::Mesh>*) objVptr;
  delete pMesh;
  #}embed
  MeshPtr_destructor_cpp(obj)
  return

cdef void PetscMat_destructor(void* obj):
  """
  Destroy PetscMat.
  """
  #embed{ void PetscMat_destructor_cpp(void* objVptr)
  assert(0 != objVptr);
  PetscMat* mat = (PetscMat*) objVptr;
  PetscErrorCode err = MatDestroy(*mat);
  if (err) {
    PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
    throw std::runtime_error("Could not destroy PETSc matrix.");
  } // if
  #}embed
  PetscMat_destructor_cpp(obj)
  return

cdef void FieldsManager_destructor(void* obj):
  """
  Destroy FieldsManager.
  """
  #embed{ void FieldsManager_destructor_cpp(void* objVptr)
  pylith::topology::FieldsManager* manager = (pylith::topology::FieldsManager*) objVptr;
  delete manager;
  #}embed
  FieldsManager_destructor_cpp(obj)
  return

# ----------------------------------------------------------------------

cimport mpi
import mpi

# ----------------------------------------------------------------------
cdef class Mesh:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* MeshPtr_constructor()
    void* result = 0;
    try {
      ALE::Obj<pylith::Mesh>* mesh = new ALE::Obj<pylith::Mesh>;
      assert(0 != mesh);
      result = (void*) mesh;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    self.thisptr = MeshPtr_constructor()
    self.handle = self._createHandle()
    self.name = "pylith_topology_Mesh"
    return


  def getRealSection(self, label):
    """
    Get real section from mesh.
    """
    # create shim for getRealSection
    #embed{ void* Mesh_getRealSection(void* objVptr, char* label)    
    void* result = 0;
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<pylith::real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_getRealSection(self.thisptr, label)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def createRealSection(self, label, fiberDim):
    """
    Create real section in mesh.
    """
    # create shim for createRealSection
    #embed{ void* Mesh_createRealSection(void* objVptr, char* label, int fiberDim)
    void* result = 0;
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<pylith::real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      section->setChart((*mesh)->getSieve()->getChart());
      section->setFiberDimension((*mesh)->depthStratum(0), fiberDim);
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_createRealSection(self.thisptr, label, fiberDim)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def allocateRealSection(self, section):
    """
    Allocate (and zero) real section.
    """
    # create shim for allocate
    #embed{ void* Mesh_allocateRealSection(void* objVptr, void* sectionVptr)
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      ALE::Obj<pylith::real_section_type>* section =
        (ALE::Obj<pylith::real_section_type>*) sectionVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      assert(0 != section);
      assert(!section->isNull());
      (*mesh)->allocate(*section);
      (*section)->zero();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef void* ptr
    ptr = Mesh_allocateRealSection(self.thisptr, PyCObject_AsVoidPtr(section))
    return
    

  def createMatrix(self, field):
    """
    Create matrix compatible with field.
    """
    # create shim for MeshCreateMatrix
    #embed{ void* Mesh_createMatrix(void* objVptr, void* fieldVptr)
    void* result = 0;
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      assert(!field->isNull());

      PetscMat* mat = new PetscMat;
      assert(0 != mat);
      // Should make type settable by user
      //PetscErrorCode err = MeshCreateMatrix(*mesh, *field, MATMPIBAIJ, mat);
      PetscErrorCode err = MeshCreateMatrix(*mesh, *field, MATAIJ, mat);
      if (err) {
        PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
        throw std::runtime_error("Could not create PETSc Matrix.");
      } // if
      result = (void*) mat;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    ptr = Mesh_createMatrix(self.thisptr, fieldVptr)
    return PyCObject_FromVoidPtr(ptr, PetscMat_destructor)


  def view(self):
    """
    View the mesh.
    """
    # create shim for view
    #embed{ void* Mesh_view(void* objVptr)
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      (*mesh)->view("");
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    Mesh_view(self.thisptr)
    return

 
  def checkMaterialIds(self, materialIds):
    """
    Make sure material id for each cell matches id of a material.
    """
    # create shim for checkMaterialIds
    #embed{ void* Mesh_checkMaterialIds(void* objVptr, int* materialIds, int numMaterials)
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      pylith::topology::MeshOps::checkMaterialIds(*mesh, materialIds, numMaterials);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef int* materialIdVals
    materialIdVals = NULL
    numMaterials = len(materialIds);
    if numMaterials > 0:
      materialIdVals = <int*> malloc(numMaterials*sizeof(int));
    for i from 0 <= i < numMaterials:
      materialIdVals[i] = materialIds[i]
    Mesh_checkMaterialIds(self.thisptr, materialIdVals, numMaterials)
    free(materialIdVals)
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, MeshPtr_destructor)


  property debug:
    def __set__(self, value):
      """
      Set debugging flag.
      """
      # create shim for method 'debug'
      #embed{ void Mesh_debug_set(void* objVptr, int value)
      try {
        ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
        assert(0 != mesh);
        if (mesh->isNull())
          throw std::runtime_error("Cannot set debug flag when there is " \
                                   "no mesh data.");
        (*mesh)->setDebug(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Mesh_debug_set(self.thisptr, value)

    def __get__(self):
      """
      Get debugging flag.
      """
      # create shim for method 'debug'
      #embed{ int Mesh_debug_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->debug();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_debug_get(self.thisptr)

      
  property dimension:
    def __get__(self):
      """
      Get dimension of mesh (dimension of cells).
      """
      # create shim for method 'dimension'
      #embed{ int Mesh_dimension_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->getDimension();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_dimension_get(self.thisptr)

      
  property comm:
    def __get__(self):
      """
      Get MPI communicator associated with mesh.
      """
      # create shim for method 'comm'
      #embed{ void Mesh_comm_get(void* objVptr, void *vpycomm)
      try {
        ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        PyMPICommObject *pycomm = (PyMPICommObject *)vpycomm;
        pycomm->comm = (*mesh)->comm();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      cdef mpi.MPI_Comm pycomm
      pycomm = mpi.MPI_Comm()
      Mesh_comm_get(self.thisptr, <void*>pycomm)
      return pycomm

      
# ----------------------------------------------------------------------
cdef class MeshGenSimple:

  def createCubeBoundary(self, debug = 0):
    """
    Returns a Mesh that is the boundary of the unit cube
    """
    # create shim for method 'read'
    #embed{ void MeshGenerator_createCubeBoundary(int debug, void* meshVptr)
    try {
      assert(0 != meshVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      const double lower[3] = {0.0, 0.0, 0.0};
      const double upper[3] = {1.0, 1.0, 1.0};
      const int    faces[3] = {1, 1, 1};
#ifdef IMESH_TODO
      *mesh = ALE::MeshBuilder::createCubeBoundary(PETSC_COMM_WORLD, lower, upper, faces, debug);
#endif
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    mesh = Mesh()
    MeshGenerator_createCubeBoundary(debug, ptrFromHandle(mesh))
    return mesh


  def generate(self, meshBdry):
    """
    Generate a mesh from a boundary mesh.
    """
    # create shim for method 'read'
    #embed{ void MeshGenerator_generate(void* meshVptr, void* meshBdryVptr)
    try {
      assert(0 != meshVptr);
      assert(0 != meshBdryVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::Mesh>* meshBdry = (ALE::Obj<pylith::Mesh>*) meshBdryVptr;
#ifdef IMESH_TODO
      *mesh = ALE::Generator::generateMesh(*meshBdry);
#endif
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if meshBdry.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    mesh = Mesh()
    MeshGenerator_generate(ptrFromHandle(mesh), ptrFromHandle(meshBdry))
    return mesh


# ----------------------------------------------------------------------
cdef class Distributor:

  def distribute(self, mesh, partitioner):
    """
    Distribute a mesh.
    """
    # create shim for method 'distribute'
    #embed{ void Distributor_distribute(void* newMeshVptr, void* meshVptr, char *partitioner)
    try {
      assert(0 != meshVptr);
      assert(0 != newMeshVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::Mesh>* newMesh = (ALE::Obj<pylith::Mesh>*) newMeshVptr;
      pylith::topology::Distributor::distribute(newMesh, *mesh, partitioner);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    newMesh = Mesh()
    Distributor_distribute(ptrFromHandle(newMesh), ptrFromHandle(mesh),
                           partitioner)
    return newMesh


  def write(self, writer, mesh, cs):
    """
    Write partitioning information to file..
    """
    # create shim for method 'write'
    #embed{ void Distributor_write(void* writerVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != writerVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      pylith::meshio::DataWriter* writer =
        (pylith::meshio::DataWriter*) writerVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      pylith::topology::Distributor::write(writer, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if writer.name != "pylith_meshio_DataWriter":
      raise TypeError, \
            "Argument 'writer' must be extension module type 'DataWriter'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    if cs.name != "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."
    Distributor_write(ptrFromHandle(writer), ptrFromHandle(mesh),
                      ptrFromHandle(cs))
    return


# ----------------------------------------------------------------------
cdef void MeshRefiner_destructor(void* obj):
  """
  Destroy MeshRefiner object.
  """
  # create shim for destructor
  #embed{ void MeshRefiner_destructor_cpp(void* objVptr)
  pylith::topology::MeshRefiner* pRefiner =
    (pylith::topology::MeshRefiner*) objVptr;
  delete pRefiner;
  #}embed
  MeshRefiner_destructor_cpp(obj)
  return


cdef class MeshRefiner:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_topology_meshrefiner"
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    return PyCObject_FromVoidPtr(self.thisptr, MeshRefiner_destructor)


  def write(self, writer, mesh, cs):
    """
    Write refined mesh to file..
    """
    # create shim for method 'write'
    #embed{ void MeshRefiner_write(void* writerVptr, void* meshVptr, void* csVptr)
    try {
      assert(0 != writerVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      pylith::meshio::DataWriter* writer =
        (pylith::meshio::DataWriter*) writerVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      pylith::topology::MeshRefiner::write(writer, *mesh, cs);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if writer.name != "pylith_meshio_DataWriter":
      raise TypeError, \
            "Argument 'writer' must be extension module type 'DataWriter'."
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument 'mesh' must be extension module type 'Mesh'."
    if cs.name != "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."
    MeshRefiner_write(ptrFromHandle(writer), ptrFromHandle(mesh),
                      ptrFromHandle(cs))
    return


# ----------------------------------------------------------------------
cdef class RefineUniform(MeshRefiner):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* RefineUniform_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::topology::RefineUniform);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    MeshRefiner.__init__(self)
    self.thisptr = RefineUniform_constructor()
    self.handle = self._createHandle()
    return


  def refine(self, mesh, levels):
    """
    Refine mesh.
    """
    # create shim for method 'refine'
    #embed{ void RefineUniform_refine(void* objVptr, void* newMeshVptr, void* meshVptr, int levels)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      assert(0 != newMeshVptr);
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      ALE::Obj<pylith::Mesh>* newMesh = (ALE::Obj<pylith::Mesh>*) newMeshVptr;
      ((pylith::topology::RefineUniform*) objVptr)->refine(newMesh, *mesh, levels);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    newMesh = Mesh()
    RefineUniform_refine(self.thisptr, ptrFromHandle(newMesh),
                         ptrFromHandle(mesh), levels)
    return newMesh



# ----------------------------------------------------------------------
cdef class FieldsManager:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self, mesh):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* FieldsManager_constructor(void* meshVptr)
    void* result = 0;
    try {
      ALE::Obj<pylith::Mesh>* mesh = (ALE::Obj<pylith::Mesh>*) meshVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      pylith::topology::FieldsManager* manager =
        new pylith::topology::FieldsManager(*mesh);
      result = (void*) manager;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    self.thisptr = FieldsManager_constructor(ptrFromHandle(mesh))
    self.handle = self._createHandle()
    self.name = "pylith_topology_FieldsManager"
    return


  def getReal(self, label):
    """
    Get real field over mesh.
    """
    # create shim for getReal
    #embed{ void* FieldsManager_getReal(void* objVptr, char* label)
    void* result = 0;
    try {
      pylith::topology::FieldsManager* manager =
      (pylith::topology::FieldsManager*) objVptr;
      assert(0 != manager);
      const ALE::Obj<pylith::real_section_type>& field =
        manager->getReal(label);
      assert(!field.isNull());
      result = (void*) &field;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = FieldsManager_getReal(self.thisptr, label)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def addReal(self, label):
    """
    Create real section over mesh.
    """
    # create shim for addReal
    #embed{ void FieldsManager_addReal(void* objVptr, char* label)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->addReal(label);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_addReal(self.thisptr, label)
    return


  def delReal(self, label):
    """
    Delete real section over mesh.
    """
    # create shim for delReal
    #embed{ void FieldsManager_delReal(void* objVptr, char* label)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->delReal(label);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_delReal(self.thisptr, label)
    return


  def setFiberDimension(self, label, fiberDim, points):
    """
    Set fiber dimension for field.
    """
    # create shim for setFiberDimension
    #embed{ void FieldsManager_setFiberDimension(void* objVptr, char* label, int fiberDim, char* points)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->setFiberDimension(label, fiberDim, points);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_setFiberDimension(self.thisptr, label, fiberDim, points)
    return


  def allocate(self, label):
    """
    Allocate field.
    """
    # create shim for allocate
    #embed{ void FieldsManager_allocate(void* objVptr, char* label)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->allocate(label);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_allocate(self.thisptr, label)
    return


  def copyLayout(self, label):
    """
    Copy layout of given section to all other sections in manager.
    """
    # create shim for copyLayout
    #embed{ void FieldsManager_copyLayout(void* objVptr, char* label)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->copyLayout(label);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_copyLayout(self.thisptr, label)
    return


  def copyLayoutFromSrc(self, field):
    """
    Copy layout of section to all sections in manager.
    """
    # create shim for copyLayout
    #embed{ void FieldsManager_copyLayoutFromSrc(void* objVptr, void* fieldVptr)
    try {
      assert(0 != objVptr);
      assert(0 != fieldVptr);
      const ALE::Obj<pylith::real_section_type>* field =
        (ALE::Obj<pylith::real_section_type>*) fieldVptr;
      ((pylith::topology::FieldsManager*) objVptr)->copyLayout(*field);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_copyLayoutFromSrc(self.thisptr, PyCObject_AsVoidPtr(field))
    return


  def solutionField(self, name):
    """
    Set name of field corresponding to solution.
    """
    # create shim for solutionField
    #embed{ void FieldsManager_solutionField(void* objVptr, char* name)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->solutionField(name);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_solutionField(self.thisptr, name)


  def getSolution(self):
    """
    Get field corresponding to solution.
    """
    # create shim for getSolution
    #embed{ void* FieldsManager_getSolution(void* objVptr)
    void* result = 0;
    try {
      assert(0 != objVptr);
      const ALE::Obj<pylith::real_section_type>& field =
        ((pylith::topology::FieldsManager*) objVptr)->getSolution();
      result = (void*) &field;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = FieldsManager_getSolution(self.thisptr)
    return PyCObject_FromVoidPtr(ptr, NULL)


  def createHistory(self, labels):
    """
    Create history manager for a subset of the managed fields.
    """
    # create shim for createHistory
    #embed{ void FieldsManager_createHistory(void* objVptr, char** labels, int size)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->createHistory((const char**) labels, size);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef char** labelsPtr
    size = len(labels)
    labelsPtr = <char**> malloc(size*sizeof(char*))
    for i from 0 <= i < size:
      labelsPtr[i] = labels[i]
    FieldsManager_createHistory(self.thisptr, labelsPtr, size)
    free(labelsPtr)
    return


  def shiftHistory(self):
    """
    Shift fields in history.
    """
    # create shim for shiftHistory
    #embed{ void FieldsManager_shiftHistory(void* objVptr)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->shiftHistory();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_shiftHistory(self.thisptr)
    return


  def getFieldByHistory(self, index):
    """
    Get field in history by position.
    """
    # create shim for getFieldByHistory
    #embed{ void* FieldsManager_getFieldByHistory(void* objVptr, int index)
    void* result = 0;
    try {
      assert(0 != objVptr);
      const ALE::Obj<pylith::real_section_type>& field =
        ((pylith::topology::FieldsManager*) objVptr)->getFieldByHistory(index);
      result = (void*) &field;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = FieldsManager_getFieldByHistory(self.thisptr, index)
    return PyCObject_FromVoidPtr(ptr, NULL)


  def createCustomAtlas(self, label, id):
    """
    Create custom atlases for fields.
    """
    # create shim for createCustomAtlas
    #embed{ void FieldsManager_createCustomAtlas(void* objVptr, char* label, int id)
    try {
      assert(0 != objVptr);
      ((pylith::topology::FieldsManager*) objVptr)->createCustomAtlas(label, id);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    FieldsManager_createCustomAtlas(self.thisptr, label, id)
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, FieldsManager_destructor)
    

# ----------------------------------------------------------------------
def zeroRealSection(section):
  """
  Zero real section.
  """
  # create shim for zero section
  #embed{ void* Section_zero(void* objVptr)
  try {
    ALE::Obj<pylith::real_section_type>* section =
      (ALE::Obj<pylith::real_section_type>*) objVptr;
    assert(!section->isNull());
    (*section)->zero();
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  cdef void* ptr
  ptr = PyCObject_AsVoidPtr(section)
  Section_zero(ptr)
  return


# ----------------------------------------------------------------------
def completeSection(mesh, section):
  """
  Complete the section across the mesh overlap.
  """
  # create shim for method 'completeSection'
  #embed{ void Section_complete(void* sectionVptr, void* meshVptr)
  try {
    assert(0 != sectionVptr);
    assert(0 != meshVptr);
    ALE::Obj<pylith::Mesh>* mesh =
      (ALE::Obj<pylith::Mesh>*) meshVptr;
    ALE::Obj<pylith::real_section_type>* section =
      (ALE::Obj<pylith::real_section_type>*) sectionVptr;
#if 1
    ALE::Completion::completeSectionAdd((*mesh)->getSendOverlap(), (*mesh)->getRecvOverlap(), *section, *section);
#else
    ALE::Distribution<pylith::Mesh>::completeSection(*mesh, *section);
#endif
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  if mesh.name != "pylith_topology_Mesh":
    print mesh.name
    raise TypeError, \
          "Argument must be extension module type 'Mesh'."
  Section_complete(PyCObject_AsVoidPtr(section),
                   ptrFromHandle(mesh))
  return


# ----------------------------------------------------------------------
def copyRealSection(dst, src):
  """
  Copy values from one section into another, ignoring constraints.
  """
  # create shim for Field::copy()
  #embed{ void Section_copyRealSection(void* objVptr, void* srcVptr)
  try {
    ALE::Obj<pylith::real_section_type>* dst =
      (ALE::Obj<pylith::real_section_type>*) objVptr;
    assert(!dst->isNull());
    ALE::Obj<pylith::real_section_type>* src =
      (ALE::Obj<pylith::real_section_type>*) srcVptr;
    assert(!src->isNull());
    (*dst)->zero();
    (*dst)->axpy(1.0, *src);
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  Section_copyRealSection(PyCObject_AsVoidPtr(dst),
                          PyCObject_AsVoidPtr(src))
  return


# ----------------------------------------------------------------------
def addRealSections(dst, srcA, srcB):
  """
  Add two sections, storing result in third section.
  """
  # create shim for Field::add()
  #embed{ void Section_addRealSections(void* objVptr, void* aVptr, void* bVptr)
  try {
    ALE::Obj<pylith::real_section_type>* dst =
      (ALE::Obj<pylith::real_section_type>*) objVptr;
    assert(!dst->isNull());
    ALE::Obj<pylith::real_section_type>* a =
      (ALE::Obj<pylith::real_section_type>*) aVptr;
    assert(!a->isNull());
    ALE::Obj<pylith::real_section_type>* b =
      (ALE::Obj<pylith::real_section_type>*) bVptr;
    assert(!b->isNull());
    (*dst)->add(*a, *b);
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  Section_addRealSections(PyCObject_AsVoidPtr(dst),
                          PyCObject_AsVoidPtr(srcA),
                          PyCObject_AsVoidPtr(srcB))
  return


# ----------------------------------------------------------------------
def sectionView(field, label):
  """
  View section.
  """
  # create shim for section::view()
  #embed{ void Section_view(void* objVptr, char* label)
  try {
    ALE::Obj<pylith::real_section_type>* field =
      (ALE::Obj<pylith::real_section_type>*) objVptr;
    assert(0 != field);
    assert(!field->isNull());
    (*field)->view(label);
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  Section_view(PyCObject_AsVoidPtr(field), label)
  return


# End of file 
