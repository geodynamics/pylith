# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include <Mesh.hh>
#include <Distribution.hh>
#include <petscmesh.h>
#include "pylith/utils/petscfwd.h"

#include <stdexcept>
#include <Python.h>
#include <assert.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

cdef void MeshPtr_destructor(void* obj):
  """
  Destroy Petsc Mesh.
  """
  #embed{ void MeshPtr_destructor_cpp(void* objVptr)
  ALE::Obj<ALE::Mesh>* pMesh = (ALE::Obj<ALE::Mesh>*) objVptr;
  delete pMesh;
  #}embed
  MeshPtr_destructor_cpp(obj)
  return

cdef void PetscMat_destructor(void* obj):
  """
  Destroy PetscMat.
  """
  #embed{ void PetscMat_destructor_cpp(void* objVptr)
  assert(0 != objVptr);
  PetscMat* mat = (PetscMat*) objVptr;
  PetscErrorCode err = MatDestroy(*mat);
  if (err) {
    PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
    throw std::runtime_error("Could not destroy PETSc matrix.");
  } // if
  #}embed
  PetscMat_destructor_cpp(obj)
  return

# ----------------------------------------------------------------------
cdef class Mesh:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* MeshPtr_constructor()
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = new ALE::Obj<ALE::Mesh>;
      assert(0 != mesh);
      result = (void*) mesh;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    self.thisptr = MeshPtr_constructor()
    self.handle = self._createHandle()
    self.name = "pylith_topology_Mesh"
    return


  def getRealSection(self, label):
    """
    Get real section from mesh.
    """
    # create shim for getRealSection
    #embed{ void* Mesh_getRealSection(void* objVptr, char* label)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_getRealSection(self.thisptr, label)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def createRealSection(self, label, fiberDim):
    """
    Create real section in mesh.
    """
    # create shim for createRealSection
    #embed{ void* Mesh_createRealSection(void* objVptr, char* label, int fiberDim)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      section->setFiberDimension((*mesh)->depthStratum(0), fiberDim);
      (*mesh)->allocate(section);
      section->zero();
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_createRealSection(self.thisptr, label, fiberDim)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def createMatrix(self, field):
    """
    Create matrix compatible with field.
    """
    # create shim for MeshCreateMatrix
    #embed{ void* Mesh_createMatrix(void* objVptr, void* fieldVptr)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>* field =
        (ALE::Obj<real_section_type>*) fieldVptr;
      assert(!field->isNull());

      PetscMat* mat = new PetscMat;
      assert(0 != mat);
      PetscErrorCode err = MeshCreateMatrix(*mesh, *field, MATMPIBAIJ, mat);
      if (err) {
        PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
        throw std::runtime_error("Could not create PETSc Matrix.");
      } // if
      result = (void*) mat;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    ptr = Mesh_createMatrix(self.thisptr, fieldVptr)
    return PyCObject_FromVoidPtr(ptr, PetscMat_destructor)

  def distribute(self, height = 0, partitioner = None):
    """
    Distribute the mesh across processes.
    """
    # create shim for MeshDistribute
    #embed{ void* Mesh_distribute(void* objVptr, int height, char *partitioner)
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      ALE::Obj<ALE::Mesh>* newMesh = new ALE::Obj<ALE::Mesh>;
      assert(0 != mesh);
      assert(0 != newMesh);
      assert(!mesh->isNull());
      assert(height >= 0);

      if (partitioner == NULL) {
        (*newMesh) = ALE::Distribution<ALE::Mesh>::distributeMesh(*mesh);
      } else {
        (*newMesh) = ALE::Distribution<ALE::Mesh>::distributeMesh(*mesh, 0, partitioner);
      }
      result = (void*) newMesh;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_distribute(self.thisptr, height, partitioner)
    return PyCObject_FromVoidPtr(ptr, MeshPtr_destructor)
    

  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, MeshPtr_destructor)


  property debug:
    def __set__(self, value):
      """
      Set debugging flag.
      """
      # create shim for method 'debug'
      #embed{ void Mesh_debug_set(void* objVptr, int value)
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        if (mesh->isNull())
          throw std::runtime_error("Cannot set debug flag when there is " \
                                   "no mesh data.");
        (*mesh)->setDebug(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Mesh_debug_set(self.thisptr, value)

    def __get__(self):
      """
      Get debugging flag.
      """
      # create shim for method 'debug'
      #embed{ int Mesh_debug_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->debug();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_debug_get(self.thisptr)

      
  property dimension:
    def __get__(self):
      """
      Get dimension of mesh (dimension of cells).
      """
      # create shim for method 'dimension'
      #embed{ int Mesh_dimension_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->getDimension();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_dimension_get(self.thisptr)

      
def zeroRealSection(section):
  """
  Zero real section.
  """
  # create shim for zero section
  #embed{ void* Section_zero(void* objVptr)
  typedef ALE::Mesh::real_section_type real_section_type;
  
  try {
    ALE::Obj<real_section_type>* section =
      (ALE::Obj<real_section_type>*) objVptr;
    assert(!section->isNull());
    (*section)->zero();
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  cdef void* ptr
  ptr = PyCObject_AsVoidPtr(section)
  Section_zero(ptr)
  return


# End of file 
