# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/utils/sievetypes.hh"
#include "pylith/utils/petscfwd.h"
#include <Generator.hh>
#include <Distribution.hh>

#include <stdexcept>
#include <Python.h>
#include <assert.h>
#include <mpi.h>
#include "mpi/pympi.h"
#}header

# ----------------------------------------------------------------------

cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

cdef void MeshPtr_destructor(void* obj):
  """
  Destroy Petsc Mesh.
  """
  #embed{ void MeshPtr_destructor_cpp(void* objVptr)
  ALE::Obj<ALE::Mesh>* pMesh = (ALE::Obj<ALE::Mesh>*) objVptr;
  delete pMesh;
  #}embed
  MeshPtr_destructor_cpp(obj)
  return

cdef void PetscMat_destructor(void* obj):
  """
  Destroy PetscMat.
  """
  #embed{ void PetscMat_destructor_cpp(void* objVptr)
  assert(0 != objVptr);
  PetscMat* mat = (PetscMat*) objVptr;
  PetscErrorCode err = MatDestroy(*mat);
  if (err) {
    PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
    throw std::runtime_error("Could not destroy PETSc matrix.");
  } // if
  #}embed
  PetscMat_destructor_cpp(obj)
  return

# ----------------------------------------------------------------------

cimport mpi
import mpi

# ----------------------------------------------------------------------

cdef class Mesh:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* MeshPtr_constructor()
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = new ALE::Obj<ALE::Mesh>;
      assert(0 != mesh);
      result = (void*) mesh;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    self.thisptr = MeshPtr_constructor()
    self.handle = self._createHandle()
    self.name = "pylith_topology_Mesh"
    return


  def getRealSection(self, label):
    """
    Get real section from mesh.
    """
    # create shim for getRealSection
    #embed{ void* Mesh_getRealSection(void* objVptr, char* label)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_getRealSection(self.thisptr, label)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def createRealSection(self, label, fiberDim):
    """
    Create real section in mesh.
    """
    # create shim for createRealSection
    #embed{ void* Mesh_createRealSection(void* objVptr, char* label, int fiberDim)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>& section =
        (*mesh)->getRealSection(label);
      assert(!section.isNull());
      section->setFiberDimension((*mesh)->depthStratum(0), fiberDim);
      result = (void*) &section;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    ptr = Mesh_createRealSection(self.thisptr, label, fiberDim)
    return PyCObject_FromVoidPtr(ptr, NULL)
    

  def allocateRealSection(self, section):
    """
    Allocate (and zero) real section.
    """
    # create shim for allocate
    #embed{ void* Mesh_allocateRealSection(void* objVptr, void* sectionVptr)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      ALE::Obj<pylith::real_section_type>* section =
        (ALE::Obj<pylith::real_section_type>*) sectionVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      assert(0 != section);
      assert(!section->isNull());
      (*mesh)->allocate(*section);
      (*section)->zero();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef void* ptr
    ptr = Mesh_allocateRealSection(self.thisptr, PyCObject_AsVoidPtr(section))
    return
    

  def createMatrix(self, field):
    """
    Create matrix compatible with field.
    """
    # create shim for MeshCreateMatrix
    #embed{ void* Mesh_createMatrix(void* objVptr, void* fieldVptr)
    typedef ALE::Mesh::real_section_type real_section_type;
    
    void* result = 0;
    try {
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
      assert(0 != mesh);
      assert(!mesh->isNull());
      const ALE::Obj<real_section_type>* field =
        (ALE::Obj<real_section_type>*) fieldVptr;
      assert(!field->isNull());

      PetscMat* mat = new PetscMat;
      assert(0 != mat);
      PetscErrorCode err = MeshCreateMatrix(*mesh, *field, MATMPIBAIJ, mat);
      if (err) {
        PetscError(__LINE__,__FUNCT__,__FILE__,__SDIR__,err,0," ");
        throw std::runtime_error("Could not create PETSc Matrix.");
      } // if
      result = (void*) mat;
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed
    cdef void* ptr
    cdef void* fieldVptr
    fieldVptr = PyCObject_AsVoidPtr(field)
    ptr = Mesh_createMatrix(self.thisptr, fieldVptr)
    return PyCObject_FromVoidPtr(ptr, PetscMat_destructor)


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, MeshPtr_destructor)


  property debug:
    def __set__(self, value):
      """
      Set debugging flag.
      """
      # create shim for method 'debug'
      #embed{ void Mesh_debug_set(void* objVptr, int value)
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        if (mesh->isNull())
          throw std::runtime_error("Cannot set debug flag when there is " \
                                   "no mesh data.");
        (*mesh)->setDebug(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Mesh_debug_set(self.thisptr, value)

    def __get__(self):
      """
      Get debugging flag.
      """
      # create shim for method 'debug'
      #embed{ int Mesh_debug_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->debug();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_debug_get(self.thisptr)

      
  property dimension:
    def __get__(self):
      """
      Get dimension of mesh (dimension of cells).
      """
      # create shim for method 'dimension'
      #embed{ int Mesh_dimension_get(void* objVptr)
      int result = 0;
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        result = (*mesh)->getDimension();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Mesh_dimension_get(self.thisptr)

      
  property comm:
    def __get__(self):
      """
      Get MPI communicator associated with mesh.
      """
      # create shim for method 'comm'
      #embed{ void Mesh_comm_get(void* objVptr, void *vpycomm)
      try {
        ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) objVptr;
        assert(0 != mesh);
        assert(!mesh->isNull());
        PyMPICommObject *pycomm = (PyMPICommObject *)vpycomm;
        pycomm->comm = (*mesh)->comm();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      cdef mpi.MPI_Comm pycomm
      pycomm = mpi.MPI_Comm()
      Mesh_comm_get(self.thisptr, <void*>pycomm)
      return pycomm

      
# ----------------------------------------------------------------------
cdef class MeshGenSimple:

  def createCubeBoundary(self, debug = 0):
    """
    Returns a Mesh that is the boundary of the unit cube
    """
    # create shim for method 'read'
    #embed{ void MeshGenerator_createCubeBoundary(int debug, void* meshVptr)
    try {
      assert(0 != meshVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      const double lower[3] = {0.0, 0.0, 0.0};
      const double upper[3] = {1.0, 1.0, 1.0};
      const int    faces[3] = {1, 1, 1};
      *mesh = ALE::MeshBuilder::createCubeBoundary(PETSC_COMM_WORLD, lower, upper, faces, debug);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    mesh = Mesh()
    MeshGenerator_createCubeBoundary(debug, ptrFromHandle(mesh))
    return mesh


  def generate(self, meshBdry):
    """
    Generate a mesh from a boundary mesh.
    """
    # create shim for method 'read'
    #embed{ void MeshGenerator_generate(void* meshVptr, void* meshBdryVptr)
    try {
      assert(0 != meshVptr);
      assert(0 != meshBdryVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ALE::Obj<ALE::Mesh>* meshBdry = (ALE::Obj<ALE::Mesh>*) meshBdryVptr;
      *mesh = ALE::Generator::generateMesh(*meshBdry);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if meshBdry.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    mesh = Mesh()
    MeshGenerator_generate(ptrFromHandle(mesh), ptrFromHandle(meshBdry))
    return mesh


# ----------------------------------------------------------------------
cdef class Distributor:

  def distribute(self, mesh, partitioner):
    """
    Distribute a mesh.
    """
    # create shim for method 'distribute'
    #embed{ void Distributor_distribute(void* newMeshVptr, void* meshVptr, char *partitioner)
    try {
      assert(0 != meshVptr);
      assert(0 != newMeshVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      ALE::Obj<ALE::Mesh>* newMesh = (ALE::Obj<ALE::Mesh>*) newMeshVptr;
      if (strlen(partitioner) > 0) {
        *newMesh = ALE::Distribution<ALE::Mesh>::distributeMesh(*mesh);
      } else {
        *newMesh =
          ALE::Distribution<ALE::Mesh>::distributeMesh(*mesh, 0, partitioner);
      }
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    if mesh.name != "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type 'Mesh'."
    newMesh = Mesh()
    Distributor_distribute(ptrFromHandle(newMesh), ptrFromHandle(mesh),
                           partitioner)
    return newMesh


# ----------------------------------------------------------------------
def zeroRealSection(section):
  """
  Zero real section.
  """
  # create shim for zero section
  #embed{ void* Section_zero(void* objVptr)
  typedef ALE::Mesh::real_section_type real_section_type;
  
  try {
    ALE::Obj<real_section_type>* section =
      (ALE::Obj<real_section_type>*) objVptr;
    assert(!section->isNull());
    (*section)->zero();
  } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
  } catch (const ALE::Exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.msg().c_str()));
  } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
  } // try/catch
  #}embed
  cdef void* ptr
  ptr = PyCObject_AsVoidPtr(section)
  Section_zero(ptr)
  return


# End of file 
