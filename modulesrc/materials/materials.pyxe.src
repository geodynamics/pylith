# -*- Pyrex -*-
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "pylith/materials/Material.hh"
#include "pylith/materials/ElasticMaterial.hh"
#include "pylith/materials/ElasticStrain1D.hh"
#include "pylith/materials/ElasticStress1D.hh"
#include "pylith/materials/ElasticIsotropic3D.hh"
#include "pylith/materials/ElasticPlaneStrain.hh"
#include "pylith/materials/ElasticPlaneStress.hh"
#include "pylith/materials/MaxwellIsotropic3D.hh"
#include "pylith/materials/GenMaxwellIsotropic3D.hh"

#include <assert.h>
#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)

cdef void Material_destructor(void* obj):
  """
  Destroy Material object.
  """
  # create shim for destructor
  #embed{ void Material_destructor_cpp(void* pObj)
  pylith::materials::Material* pM =
    (pylith::materials::Material*) pObj;
  delete pM;
  #}embed
  Material_destructor_cpp(obj)
  return


# ----------------------------------------------------------------------
cdef class Material:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "pylith_materials_Material"
    return


  def initialize(self, mesh, cs, quadrature):
    """
    Initialize material by getting physical property parameters from
    database.
    """
    # create shim for method 'initialize'
    #embed{ void Material_initialize(void* objVptr, void* meshVptr, void* csVptr, void* qVptr)
    try {
      assert(0 != objVptr);
      assert(0 != meshVptr);
      assert(0 != csVptr);
      assert(0 != qVptr);
      ALE::Obj<ALE::Mesh>* mesh = (ALE::Obj<ALE::Mesh>*) meshVptr;
      spatialdata::geocoords::CoordSys* cs =
        (spatialdata::geocoords::CoordSys*) csVptr;
      pylith::feassemble::Quadrature* quadrature =
        (pylith::feassemble::Quadrature*) qVptr;
      ((pylith::materials::Material*) objVptr)->initialize(*mesh, cs, quadrature);
      } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not mesh.name == "pylith_topology_Mesh":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::topology::Mesh'."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument must be extension module type " \
            "'spatialdata::geocoords::CoordSys'."
    if not quadrature.name == "pylith_feassemble_Quadrature":
      raise TypeError, \
            "Argument must be extension module type " \
            "'pylith::feassemble::Quadrature'."
    Material_initialize(self.thisptr, ptrFromHandle(mesh), ptrFromHandle(cs),
                        ptrFromHandle(quadrature))
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, Material_destructor)


  property db:
    def __set__(self, value):
      """
      Set database for physical property parameters.
      """
      # create shim for method 'db'
      #embed{ void Material_db_set(void* objVptr, void* dbVptr)
      try {
        assert(0 != objVptr);
        assert(0 != dbVptr);
        spatialdata::spatialdb::SpatialDB* db =
          (spatialdata::spatialdb::SpatialDB*) dbVptr;
        ((pylith::materials::Material*) objVptr)->db(db);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not value.name == "spatialdata_spatialdb_SpatialDB":
        raise TypeError, \
              "Argument must be extension module type " \
              "'spatialdata::spatialdb::SpatialDB'."
      Material_db_set(self.thisptr, ptrFromHandle(value))


  property id:
    def __set__(self, value):
      """
      Set identifier of material.
      """
      # create shim for method 'id'
      #embed{ void Material_id_set(void* objVptr, int value)
      try {
        assert(0 != objVptr);
        ((pylith::materials::Material*) objVptr)->id(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Material_id_set(self.thisptr, value)

    def __get__(self):
      """
      Get identifier of material.
      """
      # create shim for method 'id'
      #embed{ int Material_id_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::materials::Material*) objVptr)->id();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Material_id_get(self.thisptr)


  property label:
    def __set__(self, value):
      """
      Set label of material.
      """
      # create shim for method 'label'
      #embed{ void Material_label_set(void* objVptr, char* value)
      try {
        assert(0 != objVptr);
        ((pylith::materials::Material*) objVptr)->label(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Material_label_set(self.thisptr, value)


  property dimension:
    def __get__(self):
      """
      Get dimension associated with material.
      """
      # create shim for method 'dimension'
      #embed{ int Material_dimension_get(void* objVptr)
      int result = 0;
      try {
        assert(0 != objVptr);
        result = ((pylith::materials::Material*) objVptr)->dimension();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return result;
      #}embed
      return Material_dimension_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class ElasticMaterial(Material):

  def __init__(self):
    """
    Constructor.
    """
    Material.__init__(self)
    self.name = "pylith_materials_ElasticMaterial"
    return


  property useElasticBehavior:
    def __set__(self, value):
      """
      Set useElasticBehavior flag.
      """
      # create shim for method 'useElasticBehavior'
      #embed{ void Material_useElasticBehavior_set(void* objVptr, int value)
      try {
        assert(0 != objVptr);
        ((pylith::materials::ElasticMaterial*) objVptr)->useElasticBehavior(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (const ALE::Exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.msg().c_str()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Material_useElasticBehavior_set(self.thisptr, value)


# ----------------------------------------------------------------------
cdef class ElasticStrain1D(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticStrain1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::ElasticStrain1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = ElasticStrain1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class ElasticStress1D(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticStress1D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::ElasticStress1D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = ElasticStress1D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class ElasticPlaneStrain(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticPlaneStrain_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::ElasticPlaneStrain);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = ElasticPlaneStrain_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class ElasticPlaneStress(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticPlaneStress_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::ElasticPlaneStress);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = ElasticPlaneStress_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class ElasticIsotropic3D(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* ElasticIsotropic3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::ElasticIsotropic3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = ElasticIsotropic3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class GenMaxwellIsotropic3D(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* GenMaxwellIsotropic3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::GenMaxwellIsotropic3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = GenMaxwellIsotropic3D_constructor()
    self.handle = self._createHandle()
    return


# ----------------------------------------------------------------------
cdef class MaxwellIsotropic3D(ElasticMaterial):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* MaxwellIsotropic3D_constructor()
    void* result = 0;
    try {
      result = (void*)(new pylith::materials::MaxwellIsotropic3D);
      assert(0 != result);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (const ALE::Exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.msg().c_str()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return result;
    #}embed

    ElasticMaterial.__init__(self)
    self.thisptr = MaxwellIsotropic3D_constructor()
    self.handle = self._createHandle()
    return

# End of file 
