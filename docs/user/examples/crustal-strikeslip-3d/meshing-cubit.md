# Cubit Mesh

## Geometry

We use a rectangular prism for the domain and construct vertical fault surfaces from the surface traces.
We adjust the dimensions of the domain to avoid small surfaces where the exteneded fault surfaces meet the domain boundaries.

:::{warning}
With Cubit, we can embed the fault surfaces in the domain analogous to what we did using Gmsh.
However, in most cases Cubit will not generate a valid mesh when there are embedded surfaces.
The workaround is to create closed volumes by extendubg the fault surfaces to other interior surfaces or the boundaries of the domain.
This can result in volumes with small angles when there are multiple fault surfaces with different strikes and dips, and you might need to adjust the geometry to create volumes that will not result in severely distorted cells.
:::

## Meshing using Python Script

We use the Python script `generate_cubit.py` to generate the mesh.
The Python script is setup so that it can be run from within Cubit or as a standalone Python script without the Cubit GUI interface.
In this example, we will run the script from within Cubit using the Journal editor.

Open the Python script `generate_cubit.py` in the Cubit journal editor.
Play the selected script or play the lines, making sure you play the first line so that Cubit uses the Python interpreter when running the script.
We specify the parameters controlling the geometry, mesh size, and cell shape near the top of the script.

:::{figure-md} fig:example:crustal:strikeslip:3d:cubit:geometry
<img src="figs/cubit-geometry.*" alt="Geometry of domain generated by Cubit." width="75%"/>

Geometry of domain generated by Cubit.
:::

:::{important}
In most cases, we store geometric entities in variables, so that we can refer to them later.
However, when we subdivide the domain using the fault surfaces, we do not know the ids of the newly created entities.
For these situations we use the GUI to identify the curves and surfaces and use the `cubit.get_idless_signature()` function to get the string identifying the geometric entity based on location.
This results in Cubit commands that are independent of the version of the underlying geometry libraries.
:::

:::{note}
We use the skeleton sizing function to set cell sizes that increases at a geometric rate with distance from the fault.
This makes it easy to specify a fine cell size near the fault where the solution has greater spatial variability and a coarse cell size near the boundaries where the solution is very smooth.
We specify the minimum cell cell that matches the cell size on the fault surfaces and the gradient in cell size (bias).
:::

After running the Python script in Cubit, you will have a corresponding Exodus-II file (`mesh_tet.exo`).
This is a NetCDF file, and it can be loaded into ParaView.
This can be done by either running ParaView and loading the file, or using the script provided in the viz directory.
For example, if ParaView is in your path, you can run the
following command:

:::{figure-md} fig:example:crustal:strikeslip:3d:cubit:tet
<img src="figs/cubit-tet.*" alt="Finite-element mesh with tetrahedral cells generated by Cubit." width="75%"/>

Finite-element mesh with tetrahedral cells generated by Cubit.
:::
