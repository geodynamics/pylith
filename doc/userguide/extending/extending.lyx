#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\begin_preamble

\end_preamble
\use_default_options false
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 2in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Extending"

\end_inset

Extending PyLith
\end_layout

\begin_layout Standard
One of the powerful features of using the Pyre framework in PyLith is the
 ability to extend the functionality of the software without altering any
 of the PyLith code.
 Any of the components can be replaced with other compatible components.
 You are already familiar with this feature from running the examples; when
 you set the spatial database to UniformDB, SimpleDB, or SCECCVMH you are
 switching between different compatible components for a spatial database
 facility.
 In this section we provide examples of how to extend PyLith for components
 that users will most likely want to replace with their own custom versions.
 You will need a familirarity with Python, Makefiles, and C++ to write your
 own components.
 The primary steps in constructing a component to extend PyLith' functionality
 include:
\end_layout

\begin_layout Enumerate
Setting up the sources files for the component or set of components based
 on the templates.
\end_layout

\begin_layout Enumerate
Edit the Python source file (
\family typewriter
.py
\family default
) for the component.
\end_layout

\begin_deeper
\begin_layout Enumerate
Define the user-specified properties and facilities.
\end_layout

\begin_layout Enumerate
Transfer the user-specified data from the Python object to the corresponding
 C++ object via calls to the SWIG interface object.
\end_layout

\end_deeper
\begin_layout Enumerate
Edit the C++ header (
\family typewriter
.hh
\family default
) and implementation files (
\family typewriter
.cc
\family default
) for the component.
\end_layout

\begin_deeper
\begin_layout Enumerate
Implement the methods required to satisfy the interface definition of the
 component.
\end_layout

\begin_layout Enumerate
Implement the desired functionality of the component in C++.
\end_layout

\end_deeper
\begin_layout Enumerate
Edit the SWIG interface files (
\family typewriter
.i
\family default
) that provide the glue between Python and C++.
\end_layout

\begin_layout Enumerate
Edit the Python source file that tests the functionality of the component.
\end_layout

\begin_layout Enumerate
Run configure, build, install, and run the tests of the component.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Extending:SpatialDatabases"

\end_inset

Spatial Databases
\end_layout

\begin_layout Standard
PyLith provides several types of spatial databases that can be used for
 specification of parameters associated with boundary conditions, earthquake
 ruptures, and physical properties.
 In this example we demonstrate how to provide a spatial database, UniformVelMod
el, for specifying elastic properties.
 The source files are included in the source for the spatialdata package
 in the 
\family typewriter
templates/spatialdb
\family default
 directory.
 The 
\family typewriter
README
\family default
 file in templates/spatialdb provides detailed instructions for the various
 steps involved and the source files contain numerous comments to help guide
 you through the customization process.
 The UniformVelModel component provides uniform physical properties: P wave
 speed, S wave speed, and density.
 Although this is a rather trivial specification of physical properties
 that could be easily done using a UniformDB, this example demonstrates
 how to create a user-defined component that matches the requirements of
 a spatial database for elastic physical properties.
 Adding additional physical properties is simply a matter of including some
 additional values in the spatial database.
 Furthermore, in cases where we are constructing a spatial database for
 a seismic velocity model, the data points are georeferenced.
 With our uniform physical properties we do not need to worry about any
 differences in coordinate systems between our seismic velocity model and
 points at which the model is queried.
 Howver, in many cases we do, so we illustrate this functionality by using
 a geographic projection as the coordinate system in our example.
\end_layout

\begin_layout Standard
Using a top-down approach the first step is to determine what information
 the user will need to supply to the component.
 Is the data for the spatial database in a file or a series of files? If
 so, file names and possible paths to a directory containing files with
 known names might be necessary.
 Are there other parameters that control the behavior of the component,
 such as a minimum shear wave speed? In our example the user supplies values
 for the P wave speed, S wave speed, and density.
 The user-supplied parameters become Pyre properties and facilities in the
 Python source file.
 Because our user supplied parameters are floating point values with dimensions,
 we create dimensional properties 
\family typewriter
vs
\family default
, 
\family typewriter
vp
\family default
, and 
\family typewriter
density
\family default
.
 In addition to defining the properties of the component, we also need to
 transfer these properties to the C++ object that does the real work.
 This is done by calling the C++ 
\family typewriter
vs()
\family default
, 
\family typewriter
vp()
\family default
, and 
\family typewriter
density()
\family default
 accessor functions that are accessible via the Python module created by
 SWIG.
\end_layout

\begin_layout Standard
In the C++ object we must implement the functions that are required by the
 spatial database interface.
 These functions are listed near the beginning of the UniformVelModel class
 definition at the top of the C++ header file, 
\family typewriter
UniformVelModel.hh
\family default
.
 The C++ object also includes the accessor functions that allow us to set
 the P wave speed, S wave speed, and density values to the user-specified
 values in the Python object.
 Additional information, such as a file name, parameters defined as data
 structures, etc.
 would be set via similar accessor functions.
 You can also add additional functions and data structures to the C++ class
 to provide the necessary operations and functionality of the spatial database.
 In SimpleDB we use a separate class to read in the spatial database and
 yet another class to perform the actual query.
 In our example the C++ object also creates and stores the UTM zone 10 geographi
c projection for the seismic velocity model.
 When the spatial database gets a query for physical properties, we transform
 the coordinates of the query point from its coordinate system to the coordinate
 system of our seismic velocity model.
\end_layout

\begin_layout Standard
In order to use SWIG to create the Python module that allows us to call
 C++ from Python, we use a 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 SWIG interface file (
\family typewriter
spatialdbcontrib.
\family default
i in this case) and then one for each object (
\family typewriter
UniformVelModel.i
\family default
 in this case).
 This greatly simplifies keeping the Python module synchronized with the
 C++ and Python code.
 The 
\family typewriter
UniformVelModel.i
\family default
 SWIG file is nearly identical to the corresponding C++ header file.
 There are a few differences as noted in the comments within the file.
 Copying and pasting the C++ header file and then doing a little cleanup
 is a very quick and easy way to construct a SWIG interface file for a C++
 object.
 Because very little changes from SWIG module to SWIG module, it is usually
 easiest to construct the 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 SWIG interface by copying and customizing an existing one.
\end_layout

\begin_layout Standard
Once the Python, C++, and SWIG interface files are complete, we are ready
 to build the module.
 The Makefile.am file defines how to compile and link the C++ library and
 generate the Python module via SWIG.
 The 
\family typewriter
configure.ac
\family default
 file contains the information used to build a configure script.
 The configure script checks to make sure it can find all of the tools needed
 to build the component (C++ compiler, Python, installed spatial database
 package, etc).
 See the README file for detailed instructions on how to generate the configure
 script, build, and install the component.
\end_layout

\begin_layout Standard
We recommend constructing tests of the component to insure that it is functionin
g properly before attempting to use it in an application.
 The 
\family typewriter
tests
\family default
 directory within 
\family typewriter
templates/spatialdb
\family default
 contains a Python script, 
\family typewriter
testcontrib.py
\family default
, that runs the tests of the UniformVelModel component defined in 
\family typewriter
TestUniformVelModel.py
\family default
.
 Normally, one would want to test each function individually to isolate
 errors and create C++ tests as well as the Python tests included here.
 In our rather simple example, we simply test the overall functionality
 of the component.
 For examples of thorough testing, see the spatialdatabase and PyLith source
 code.
\end_layout

\begin_layout Standard
Once you have built, installed, and tested the UniformVelModel, it is time
 to use it in a simple example.
 Because the seismic velocity model uses georeferenced coordinates, our
 example must also use georeferenced coordinates.
 The dislocation example in the PyLith 
\family typewriter
examples/twocells/twotet4-geopro
\family default
j directory uses UTM zone 11 coordinates.
 The spatial database package will transform the coordinates between the
 two projections as defined in the UniformVelModel 
\family typewriter
query()
\family default
 function.
 The dislocation example uses the SCEC CVM-H seismic velocity model.
 In order to replace the SCEC CVM-H seismic velocity with our uniform velocity
 model, in 
\family typewriter
pylithapp.cfg
\family default
 we replace the lines
\end_layout

\begin_layout LyX-Code
db_properties = spatialdata.spatialdb.SCECCVMH
\end_layout

\begin_layout LyX-Code
db_properties.data_dir = /home/brad/data/sceccvm-h/vx53/bin
\end_layout

\begin_layout Standard
with the lines
\end_layout

\begin_layout LyX-Code
db_properties = spatialdata.spatialdb.contrib.UniformVelModel
\end_layout

\begin_layout Standard
When you run the dislocation example, the 
\family typewriter
dislocation-statevars_info.vtk
\family default
 file should reflect the use of physical properties from the uniform seismic
 velocity with with 
\begin_inset Formula $\mu=1.69\times10^{10}\mathrm{Pa}$
\end_inset

, 
\begin_inset Formula $\lambda=1.6825\times10^{10}\mathrm{Pa}$
\end_inset

, and 
\begin_inset Formula $\rho=2500\mathrm{kg/m^{3}}$
\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Extending:BulkConstitutiveModels"

\end_inset

Bulk Constitutive Models
\end_layout

\begin_layout Standard
PyLith includes several linearly elastic and inelastic bulk constitutive
 models for 2-D and 3-D problems.
 In this example we demonstrate how to extend PyLith by adding your own
 bulk constitutive model.
 We reimplement the 2-D plane strain constitutive model while adding the
 current strain and stress tensors as state variables.
 This constitutive model, PlaneStrainState is not particularly useful, but
 it illustrates the basic steps involved in creating a bulk constitutive
 model with state variables.
 The sources files are included with the main PyLith source code in the
 templates/materials directory.
 The README file in templates/materials provides detailed instructions for
 the various steps and the source files contain numerous comments to guide
 you through the custcomization process.
\end_layout

\begin_layout Standard
In contrast to our previous example of customization of a spatial database
 which involved gathering user-specified parameters via the Pyre framework,
 there are no user-defined parameters for bulk constitutive models.
 The specification of the physical properties and state variables associated
 with the constitutive model is handled directly in the C++ code.
 As a result, the Python object for the constitutive model component is
 very simple and customization is limited to simply changing the names of
 objects.
\end_layout

\end_body
\end_document
