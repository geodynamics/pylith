<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="chapter_introduction">
    <title>Introduction</title>
    <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    <section>
        <title>Overview</title>
        <para> PyLith is a multi-scale simulation software package for earthquake physics. It is
            portable, scalable software for simulation of crustal deformation across spatial scales
            ranging from meters to hundreds of kilometers and temporal scales ranging from
            milliseconds to thousands of years. </para>
    </section>
    <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    <section>
        <title>History</title>
        <para> This first version of PyLith is a direct descendant of Lithomop and marks the first
            version that runs in parallel. Lithomop was the product of major reengineering of
            Tecton, a finite-element code for simulating static and quasi-static crustal
            deformation. The major new features present in Lithomop included dynamic memory
            allocation and the use of the Pyre simulation framework and PETSc solvers. </para>
        <para> PyLith is currently being rewritten from scratch to create a much more modular,
            powerful simulation package. This new code will include earthquake dynamics (both
            rupture propagation and seismic wave propagation). A beta release is expected in late
            2006. </para>
    </section>
    <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    <section>
        <title>Governing Equations</title>
        <para> Both LithoMop3d and PyLith-0.8 are quasi-static codes, meaning that time-dependence
            only enters through the constitutive relationships and the loading conditions. The
            description here is for the small-strain formulation, which is the only formulation
            available at present. If a large deformation solution is desired, interested users may
            contact Charles Williams (willic3@rpi.edu) about a version of the finite element code
            TECTON. </para>
        <para>The problem is formulated in terms of the stresses (<phrase role="symbol">&sigma;</phrase><emphasis><superscript>ij</superscript></emphasis>), displacements (<emphasis>u<superscript>i</superscript></emphasis>), and body forces per unit volume  (<inlinemediaobject id="g-inlineeq1"> <imageobject role="fo"> <imagedata fileref="figs/g-inlineeq1.eps" format="EPS"/> </imageobject> </inlinemediaobject>). We use standard index notation for all equations here, such that repeated indices imply summation and a comma denotes differentiation. For a general three-dimensional body, the problem must satisfy the equilibrium conditions</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq1">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq1.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(1)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>subject to the natural boundary conditions</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq2">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq2.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(2)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>and the essential boundary conditions</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq3">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq3.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(3)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>The surface of the body is <emphasis>S</emphasis>, given by</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq4">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq4.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(4)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>The <emphasis>n<subscript>j</subscript>
            </emphasis> are the components of the unit normal vector to <emphasis>S</emphasis>, the
            <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq2.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> are the components of the surface tractions, and the 
            <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq3.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> are the components of the applied displacements. The stresses are
            computed from the strains and any existing initial stresses using a given constitutive
            relationship. The strains are given by</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq5">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq5.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(5)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>For a linear elastic material, the constitutive relationship between stress and strain
            is</para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq6">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq6.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(6)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>where <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq4.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> are the initial stresses, and <emphasis>C</emphasis>
            <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq5.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> is the elastic constitutive relation.</para>
        <para> For inelastic behavior (viscous, plastic, etc.), we assume an additive decomposition
            of the strain tensor into elastic and inelastic parts, and use an integrated form of the
            classical incremental theory of plasticity. At time <emphasis>t</emphasis>+<phrase
                role="symbol">&Delta;</phrase><emphasis>t</emphasis>, he stresses are therefore computed from the total elastic
            strain: </para>
        <informaltable frame="none">
            <tgroup cols="2" colsep="0" align="center" rowsep="0">
                <tbody>
                    <row>
                        <entry align="left">
                            <mediaobject id="eq7">
                                <imageobject role="fo">
                                    <imagedata fileref="figs/g-eq7.eps" format="EPS"/>
                                </imageobject>
                            </mediaobject>
                        </entry>
                        <entry valign="middle" align="right">(7)</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>where <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq6.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> are the total strains and <inlinemediaobject>
                <imageobject role="fo">
                    <imagedata fileref="figs/g-inlineeq7.eps" format="EPS"/>
                </imageobject>
            </inlinemediaobject> are the inelastic strains, with the difference being the elastic
            strains. In our actual computations, we use a formulation that decomposes the stresses
            into the deviatoric and volumetric parts, using ideas based on the "effective stress
            function" [<emphasis>Kojic and Bathe</emphasis>, 1987]. This allows the time integration
            of stresses to be performed in terms of a single parameter related to the second
            deviatoric stress invariant.</para>
        <para>References: Kojic, M. and K.-J. Bathe, The 'Effective Stress-Function' Algorithm for
            Thermo-Elasto-Plasticity and Creep, <emphasis>Int. J. Num. Meth. Eng.</emphasis>, 24,
            1509-1532, 1987.</para>
    </section>
    <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    <section>
        <title>Software Components</title>
        <para> PyLith is separated into modules to encapsulate behavior and facilitate use across
            multiple applications. That way expert users can replace functionality of a wide variety
            of components without recompiling or polluting the main code. External packages reduce
            development time and enhance computational efficiency, for example, PyLith runs 2x
            faster by using the PETSc linear solver. </para>
        <para> PyLith is based on several programming languages. High-level code is written in
            Python; this rich, expressive interpreted language with dynamic typing reduces
            development time. Low-level code is written in Fortran 77 for fast execution. Bindings,
            written in C/C++, are used to allow the low-level code (Fortran 77) to be called from
            high-level code (Python). </para>
        <para> PyLith makes extensive use of external software. Pyre is a science neutral simulation
            framework being developed at Caltech. PETSc is used to perform operations on matrices
            and vectors in parallel. </para>
        <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++ -->
        <section>
            <title>PETSc</title>
            <para>
                <ulink url="http://www-unix.mcs.anl.gov/petsc/petsc-as/">PETSc</ulink>, the
                Portable, Extensible Toolkit for Scientific computation, provides a suite of
                routines for parallel, numerical solution of partial differential equations for
                linear and nonlinear systems with large, sparse systems of equations. PETSc includes
                solvers that implement a variety of Newton and Krylov subspace methods. It can also
                interface with many external packages, including BlockSolve95, ESSL, Matlab,
                ParMeTis, PVODE, and SPAI, thereby providing additional solvers and interaction with
                other software packages. </para>
            <para> PETSc includes interfaces for Fortran, C, and C++ for nearly all of the routines
                and PETSc can be installed on most Unix systems. PETSc can be built with user
                supplied highly optimized linear algebra routines (e.g., ATLAS and commercial
                versions of BLAS/LAPACK), thereby improving application performance. Users can use
                PETSc parallel matrices, vectors, and other data structures for most parallel
                operations, eliminating the need for explicit calls to Message Passing Interface
                (MPI) routines. Many settings and options can be controlled with PETSc specific
                command-line arguments, including selection of preconditions, solvers, and
                generation of performance logs. </para>
        </section>
        <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++ -->
        <section>
            <title>Pyre</title>
            <para> Pyre is an object-oriented environment capable of specifying and launching
                numerical simulations on multiple platforms, including Beowulf class parallel
                computers and grid computing systems. Pyre allows the binding of multiple components
                such as solid and fluid models used in Earth science simulations, and different
                meshers. The Pyre framework enables the elegant setup, modification and launching of
                massively parallel three-dimensional solver applications. </para>
            <para> Pyre is a framework, a combination of software and design philosophy that
                promotes the reuse of code. In their canonical software design book,
                    <citetitle>Design Patterns</citetitle>, Erich Gamma <emphasis>et al</emphasis>.
                condense the concept of a framework concept down to, "When you use a framework, you
                reuse the main body and write the code it calls." In the context of frameworks and
                object-oriented programming, Pyre can be thought of as a collection of classes and
                the way their instances interact. Programming applications based on Pyre will look
                similar to those written in any other object-oriented language. The Pyre framework
                contains a subset of parts that make up the overall framework. Each of those parts
                is designed to solve a specific problem. </para>
            <para> The framework approach to computation offers many advantages. It permits the
                exchange of codes and promotes the reuse of standardized software while preserving
                efficiency. Frameworks are also an efficient way to handle changes in computer
                architecture. They present programmers and scientists with a unified and
                well-defined task and allow for shared costs of the housekeeping aspects of software
                development. They provide greater institutional continuity to model development than
                piecemeal approaches. </para>
            <para> The Pyre framework incorporates features aimed at enabling the scientific
                non-expert to perform tasks easily without hindering the expert. Target features for
                end users allow complete and intuitive simulation specification, reasonable
                defaults, consistency checks of input, good diagnostics, easy access to remote
                facilities, and status monitoring. Target features for developers include easy
                access to user input, a shorter development cycle, and good debugging support. </para>
            <figure id="figure_pyre_overview">
                <title> Pyre Architecture. The integration framework is a set of cooperating
                    abstract services. </title>
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata fileref="figs/pyre_overview.eps" format="EPS"/>
                    </imageobject>
                    <imageobject role="xhtml,html">
                        <imagedata fileref="figs/pyre_overview.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </section>
    <!-- SECTION +++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    <section>
        <title>PyLith Design</title>
        <para> In transforming Lithomop, a serial code, into PyLith, a parallel code, a principal
            concern was to preserve the existing structure of the serial Fortran code. Active
            development of purely analytic features in PyLith, such as new material models or
            discretization schemes, depends on the familiarity of application scientists with the
            traditional Fortran programming paradigm. Global, topological operation should be
            strictly segregated from the existing code. In fact, with the exception of integrating
            PETSc for serial linear algebra and solver operations, PyLith can be run purely in
            serial without activating any of the parallel capabilities. </para>
        <para> In order to accomplish this separation, we use the PETSc <classname>Sieve</classname>
            structure to create a model of the serial PyLith mesh. This model is then partitioned
            and distributed to a set of processes. Each process receives a self-consistent mesh,
            meaning the pieces are overlapping. Each process then executes a serial PyLith step on
            that particular mesh piece. The PETSc linear algebra operations are overloaded, using
            the <classname>Sieve</classname> information, to produce a globally consistent field.
        </para>
    </section>
</chapter>
