#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\begin_preamble

\end_preamble
\use_default_options false
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 2in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
PyLith is a multi-scale simulation software package for earthquake physics.
 It is portable, scalable software for simulation of crustal deformation
 across spatial scales ranging from meters to hundreds of kilometers and
 temporal scales ranging from milliseconds to thousands of years.
\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
PyLith 1.0 was the first version to allow the solution of both implicit (quasi-st
atic) and explicit (dynamic) problems and was a complete rewrite of the
 original PyLith.
 PyLith 1.0 combines the functionality of EqSim 
\begin_inset CommandInset citation
LatexCommand cite
key "Aagaard:etal:2001a,Aagaard:etal:2001b"

\end_inset

 and PyLith 0.8.
 PyLith 0.8 was a direct descendant of LithoMop and was the first version
 that ran in parallel, as well as providing several other improvements over
 LithoMop.
 LithoMop was the product of major reengineering of Tecton, a finite-element
 code for simulating static and quasi-static crustal deformation.
 The major new features present in LithoMop included dynamic memory allocation
 and the use of the Pyre simulation framework and PETSc solvers.
 EqSim was written by Brad Aagaard to solve problems in earthquake dynamics,
 including rupture propagation and seismic wave propagation.
\end_layout

\begin_layout Standard
The release of PyLith 1.0 has been followed by additional releases that expand
 the number of features as well as improve performance.
 The PyLith 1.x series of releases allows the solution of both quasi-static
 and dynamic problems in one, two, or three dimensions.
 The code runs in either serial or parallel, and the design allows for relativel
y easy scripting using the Python programming language.
 Material properties and values for boundary and fault conditions are specified
 using spatial databases, which permit easy prescription of complex spatial
 variations of properties and parameters.
 Simulation parameters are generally specified through the use of simple
 ASCII files or the command line.
 At present, mesh information may be provided using a simple ASCII file
 (PyLith mesh ASCII format) or imported from CUBIT or LaGriT, two widely-used
 meshing packages.
 The elements currently available include a linear bar in 1-D, linear triangles
 and quadrilaterals in 2-D, and linear tetrahedra and hexahedra in 3-D.
 Higher-order (quadratic) elements are also supported, but it is not presently
 possible to create a quadratic mesh from the linear meshes provided by
 most meshing packages.
 Materials presently available include isotropic elastic, linear Maxwell
 viscoelastic (2-D and 3-D), generalized Maxwell viscoelastic (3-D only),
 power-law viscoelastic (3-D only), and Drucker-Prager elastoplastic (3-D
 only).
 Boundary conditions include Dirichlet (prescribed displacements and velocities)
, Neumann (traction), point forces, and absorbing boundaries.
 Cohesive elements are used to implement slip across interior surfaces (faults)
 with both kinematically-specified fault slip and slip governed by fault
 constitutive models.
\end_layout

\begin_layout Standard
PyLith is under active development and we expect a number of additions and
 improvements in the near future.
 Likely enhancements will include additional bulk and fault constitutive
 models and generation of Green's functions to be used in inversions.
\end_layout

\begin_layout Section
PyLith Workflow
\end_layout

\begin_layout Standard
PyLith is one component in the process of investigating problems in tectonics
 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Workflow-summary"

\end_inset

).
 Given a geological problem of interest, a scientist must first provide
 a geometrical representation of the desired structure.
 Once the structure has been defined, a computational mesh must be created.
 PyLith presently provides three mesh importing options: CUBIT Exodus format,
 LaGriT GMV and Pset files, and PyLith mesh ASCII format.
 The modeling of the physical processes of interest is performed by a code
 such as PyLith.
 Present output consists of VTK files which can be used by a number of visualiza
tion codes (e.g., ParaView, Visit, and MayaVi).
 In the near future, PyLith will also use the HDF5 format.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figs/workflow.eps
	scale 67
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Workflow-summary"

\end_inset

Workflow involved in going from geologic structure to problem analysis.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
PyLith Design
\end_layout

\begin_layout Standard
PyLith is separated into modules to encapsulate behavior and facilitate
 use across multiple applications.
 This allows expert users to replace functionality of a wide variety of
 components without recompiling or polluting the main code.
 PyLith employs external packages (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pylith-dependencies"

\end_inset

) to reduce development time and enhance computational efficiency; for example,
 PyLith 0.8 ran two times faster when the PETSc linear solver was used.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figs/packages.eps
	scale 40

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pylith-dependencies"

\end_inset

PyLith dependencies.
 PyLith makes direct use of several other packages, some of which have their
 own dependencies.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
PyLith is written in two programming languages.
 High-level code is written in Python; this rich, expressive interpreted
 language with dynamic typing reduces development time and permits flexible
 addition of user-contributed modules.
 This high-level code makes use of Pyre, a science-neutral simulation framework
 developed at Caltech, to link the modules together at runtime and gather
 user-input.
 Low-level code is written in C++, providing fast execution while still
 allowing an object-oriented implementation.
 This low-level code relies on PETSc to perform operations on matrices and
 vectors in parallel.
 We also make extensive use of two Python packages.
 SWIG is a package that simplifies the task of adding C++ extensions to
 Python code, and FIAT provides tabulated basis functions and numerical
 quadrature points.
 
\end_layout

\begin_layout Standard
In writing PyLith 1.0, the code was designed to be object-oriented and modular.
 Each type of module is accessed through a specified interface (set of functions
).
 This permits adding, replacing, and rewriting modules without affecting
 other parts of the code.
 This code structure simplifies code maintenance and development.
 Extending the set of code features is also easier, since developers can
 create new modules derived from the existing ones.
\end_layout

\begin_layout Standard
The new code design leverages Pyre, Sieve, and PETSc much more extensively
 than the previous version.
  Pyre is used to glue together the various modules used to construct a
 simulation and specify the parameters.
 Sieve is used for all finite-element  storage and manipulation and handles
 the creation of the PETSc matrices and vectors.
  As a result, most of the PyLith source code pertains to implementing the
 geodynamics, such as bulk rheology, boundary conditions, and slip on faults.
 
\end_layout

\begin_layout Standard
PyLith also uses FIAT to tabulate the finite-element basis functions  at
 the numerical integration (quadrature) points.
 Nemesis allows PyLith to run Python using the Message Passing Interface
 (MPI) for parallel processing.
 Additional, indirect dependencies (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pylith-dependencies"

\end_inset

) include numpy (efficient operations on numerical arrays in Python), Proj.4
 (geographic projections), and SWIG (calling C++ functions from Python).
\end_layout

\begin_layout Standard
During development, tests were constructed for nearly every module function.
 These unit tests are distributed with the source code.
 These tests are run throughout the development cycle to expose bugs and
 isolate their origin.
 As additional changes are made to the code, the tests are rerun to help
 prevent introduction of new bugs.
 A number of simple, full-scale tests, such as axial compression and extension,
 simple shear, and slip on through-going faults, have been used to test
 the code.
 Additionally, we have run the Southern California Earthquake Center crustal
 deformation and several of the spontaneous rupture benchmarks for strike-slip
 and reverse-slip to determine the relative local and global error (see
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Benchmarks"

\end_inset

).
\end_layout

\begin_layout Subsection
Pyre
\end_layout

\begin_layout Standard
Pyre is an object-oriented environment capable of specifying and launching
 numerical simulations on multiple platforms, including Beowulf-class parallel
 computers and grid computing systems.
 Pyre allows the binding of multiple components such as solid and fluid
 models used in Earth science simulations, and different meshers.
 The Pyre framework enables the elegant setup, modification and launching
 of massively parallel solver applications.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figs/pyre_overview.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pyre:Architecture"

\end_inset

Pyre Architecture.
 The integration framework is a set of cooperating abstract services.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pyre is a framework, a combination of software and design philosophy that
 promotes the reuse of code.
 In their canonical software design book, 
\emph on
Design Patterns
\emph default
, Erich Gamma 
\shape italic
et al
\shape default
.
 condense the concept of a framework concept down to, ``When you use a framework
, you reuse the main body and write the code it calls.'' In the context of
 frameworks and object-oriented programming, Pyre can be thought of as a
 collection of classes and the way their instances interact.
 Programming applications based on Pyre will look similar to those written
 in any other object-oriented language.
 The Pyre framework contains a subset of parts that make up the overall
 framework.
 Each of those parts is designed to solve a specific problem.
\end_layout

\begin_layout Standard
The framework approach to computation offers many advantages.
 It permits the exchange of codes and promotes the reuse of standardized
 software while preserving efficiency.
 Frameworks are also an efficient way to handle changes in computer architecture.
 They present programmers and scientists with a unified and well-defined
 task and allow for shared costs of the housekeeping aspects of software
 development.
 They provide greater institutional continuity to model development than
 piecemeal approaches.
\end_layout

\begin_layout Standard
The Pyre framework incorporates features aimed at enabling the scientific
 non-expert to perform tasks easily without hindering the expert.
 Target features for end users allow complete and intuitive simulation specifica
tion, reasonable defaults, consistency checks of input, good diagnostics,
 easy access to remote facilities, and status monitoring.
 Target features for developers include easy access to user input, a shorter
 development cycle, and good debugging support.
\end_layout

\begin_layout Subsection
Sieve and PETSc
\end_layout

\begin_layout Standard
PyLith 1.x makes use of a set of data structures and routines in PETSc called
 
\family typewriter
Sieve
\family default
, which is still under active development.
 
\family typewriter
Sieve
\family default
 provides data structures and routines for for representing and manipulating
 computational meshes, and it greatly simplifies finite-element computations.

\family typewriter
 Sieve
\family default
 represents the topology of the domain.
 Zero volume elements are inserted along all fault surfaces to implement
 kinematic (prescribed) or dynamic (constitutive model) implementations
 of fault slip.
 Material properties and other parameters are represented as sections (scalar
 and vector fields) over the mesh, and values for a vertex or cell can be
 retrieved by restricting the section to the vertex or cell.
 For each problem, functions are provided to calculate the residual and
 its Jacobian.
 All numerical integration is done in these functions, and parallel assembly
 is accomplished using the restrict/update paradigm of the 
\family typewriter
Sieve
\family default
 framework.
 We assemble into PETSc linear algebra objects and then call PETSc solvers.
 The solution is mapped back into a section, which can be output in VTK
 format.
\end_layout

\begin_layout Standard
PETSc 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www-unix.mcs.anl.gov/petsc/petsc-as
\end_layout

\end_inset

, the Portable, Extensible Toolkit for Scientific computation, provides
 a suite of routines for parallel, numerical solution of partial differential
 equations for linear and nonlinear systems with large, sparse systems of
 equations.
 PETSc includes solvers that implement a variety of Newton and Krylov subspace
 methods.
 It can also interface with many external packages, including ESSL, MUMPS,
 Matlab, ParMETIS, PVODE, and Hypre, thereby providing additional solvers
 and interaction with other software packages.
\end_layout

\begin_layout Standard
PETSc includes interfaces for FORTRAN 77/90, C, C++, and Python for nearly
 all of the routines, and PETSc can be installed on most Unix systems.
 PETSc can be built with user-supplied, highly optimized linear algebra
 routines (e.g., ATLAS and commercial versions of BLAS/LAPACK), thereby improving
 application performance.
 Users can use PETSc parallel matrices, vectors, and other data structures
 for most parallel operations, eliminating the need for explicit calls to
 Message Passing Interface (MPI) routines.
 Many settings and options can be controlled with PETSc-specific command-line
 arguments, including selection of preconditions, solvers, and generation
 of performance logs.
\end_layout

\end_body
\end_document
