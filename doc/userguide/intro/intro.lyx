#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\begin_preamble

\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 2in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
PyLith is a multi-scale simulation software package for earthquake physics.
 It is portable, scalable software for simulation of crustal deformation
 across spatial scales ranging from meters to hundreds of kilometers and
 temporal scales ranging from milliseconds to thousands of years.
\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
This version of PyLith (1.0) is the first version to allow the solution of
 both implicit (quasi-static) and explicit (dynamic) problems, and represents
 a complete rewrite of the original PyLith.
 This version combines the functionality of EqSim [
\series bold
BRAD
\series default
 -- ref???] and PyLith 0.8.
 PyLith 0.8 was a direct descendant of LithoMop and was the first version
 that ran in parallel, as well as providing several other improvements over
 LithoMop.
 LithoMop was the product of major reengineering of Tecton, a finite-element
 code for simulating static and quasi-static crustal deformation.
 The major new features present in Lithomop included dynamic memory allocation
 and the use of the Pyre simulation framework and PETSc solvers.
 EqSim was written by Brad Aaagaard to solve problems in earthquake dynamics,
 including rupture propagaion and seismic wave propagation.
\end_layout

\begin_layout Standard
This release of PyLith allows the solution of both quasi-static and dynamic
 problems in 1, 2, or 3 dimensions.
 The code runs in either serial or parallel mode, and the design should
 allow for relatively easy scripting using the Python programming language.
 Boundary conditions, material properties, and fault specifications are
 handled using a spatial database, which allows complex models to be easily
 specified.
 Model parameters are generally specified through the use of 
\family sans
.cfg
\family default
 files, although they can also be specified using 
\family typewriter
.pml
\family default
 files or from the command line.
 At present, mesh information may be provided using a simple ASCII format
 (PyLith ASCII format), and mesh data may also be imported from CUBIT or
 LaGriT, two widely-used meshing packages.
 The elements currently available include a linear beam (1D), linear triangles
 and quadrilaterals (2D), and linear tetrahedra and hexahedra (3D).
 Higher-order (quadratic) elements are also supported, but it is not presently
 possible to create a quadratic mesh from the linear meshes provided by
 most meshing packages.
 Materials presently available include isotropic elastic and linear Maxwell
 viscoelastic.
 Cohesive elements are used to represent faults.
 At present, only kinematically-specified fault slip is available.
 In the near future, we will provide several constitutive models for cohesive
 elements, which will allow slip to occur using several different fault
 physics models.
\end_layout

\begin_layout Standard
PyLith is under active development and we expect a number of additions and
 improvements in the near future.
 Likely enhancements will include the addition of new constitutive models
 for both volume elements and cohesive (fault) elements, automatic generation
 of higher-order elements from linear elements, and the generation of Green's
 functions to be used in inversions.
 Many of these features should be available by late Summer, 2007.
\end_layout

\begin_layout Section
PyLith Workflow
\end_layout

\begin_layout Standard
PyLith is one component in the process of investigating problems in tectonics
 (
\begin_inset LatexCommand \ref{fig:Workflow-summary}

\end_inset

).
 Given a geological problem of interest, a scientist must first provide
 a geometrical representation of the desired structure.
 Once the structure has been defined, a computational mesh must be created.
 Since there are a wide variety of mesh formats, this information must then
 be translated into something that the computational physics code can understand.
 In the case of PyLith, this task is performed by translating external formats
 into Sieve mesh data structures.
 PyLith presently provides three mesh importing options: CUBIT Exodus format,
 LaGriT GMV + pset files, and PyLith ASCII format.
 The modeling of the physical processes of interest is performed by a code
 such as PyLith.
 Once the computations have been performed, the results must be translated
 into a format that can be used by a visualization code.
 For PyLith, this task is performed by translating the Sieve data structures
 into an appropriate form.
 Present output consists of VTK format, which can be used by a number of
 visualization codes.
 In the near future, a more flexible HDF5 format is planned.
 [
\series bold
BRAD
\series default
 -- need new figure to replace this placeholder.
 If you give me the original xfig (or whatever you used), I can modify it
 accordingly)] 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename figs/workflow.pdf

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:Workflow-summary}

\end_inset

Workflow involved in going from geologic structure to problem analysis.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Software Components
\end_layout

\begin_layout Standard
PyLith is separated into modules to encapsulate behavior and facilitate
 use across multiple applications.
 That way expert users can replace functionality of a wide variety of components
 without recompiling or polluting the main code.
 External packages reduce development time and enhance computational efficiency;
 for example, PyLith 0.8 ran 2
\begin_inset Formula $\times$
\end_inset

 faster when the PETSc linear solver was used.
\end_layout

\begin_layout Standard
PyLith is based on two programming languages.
 High-level code is written in Python; this rich, expressive interpreted
 language with dynamic typing reduces development time.
 Low-level code is written in C++, providing fast execution while still
 allowing object-oriented code.
 We also make extensive use of two Python packages.
 Pyrex is a package that simplifies the task of adding C extensions to Python
 code.
 We also use pyrexembed, which extends the use of Pyrex to handle C++ code.
\end_layout

\begin_layout Standard
PyLith makes extensive use of external software.
 Pyre is a science-neutral simulation framework being developed at Caltech.
 PETSc is used to perform operations on matrices and vectors in parallel.
\end_layout

\begin_layout Subsection
PETSc
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \htmlurl[PETSc]{www-unix.mcs.anl.gov/petsc/petsc-as}

\end_inset

, the Portable, Extensible Toolkit for Scientific computation, provides
 a suite of routines for parallel, numerical solution of partial differential
 equations for linear and nonlinear systems with large, sparse systems of
 equations.
 PETSc includes solvers that implement a variety of Newton and Krylov subspace
 methods.
 It can also interface with many external packages, including ESSL, MUMPS,
 Matlab, ParMeTis, PVODE, and Hypre, thereby providing additional solvers
 and interaction with other software packages.
\end_layout

\begin_layout Standard
PETSc includes interfaces for Fortran 77/90, C, C++, and Python for nearly
 all of the routines, and PETSc can be installed on most Unix systems.
 PETSc can be built with user-supplied, highly optimized linear algebra
 routines (e.g., ATLAS and commercial versions of BLAS/LAPACK), thereby improving
 application performance.
 Users can use PETSc parallel matrices, vectors, and other data structures
 for most parallel operations, eliminating the need for explicit calls to
 Message Passing Interface (MPI) routines.
 Many settings and options can be controlled with PETSc-specific command-line
 arguments, including selection of preconditions, solvers, and generation
 of performance logs.
\end_layout

\begin_layout Standard
PyLith 0.8 and PyLith 1.0 make use of a new aspect of PETSc known as 
\family typewriter
Sieve
\family default
, which is still under active development.
 
\family typewriter
Sieve
\family default
 is a new method for representing computational meshes, and it greatly simplifie
s the task of code parallelization.
 
\family typewriter
Sieve
\family default
 also provides a number of other useful features, such as the ability to
 grab ``sections'' of a mesh that share common characteristics, such as
 elements of the same material type or nodes to which boundary conditions
 have been applied.
 This version of PyLith uses 
\family typewriter
Sieve
\family default
 much more extensively than PyLith 0.8, and should provide significantly
 better performance.
\end_layout

\begin_layout Subsection
Pyre
\end_layout

\begin_layout Standard
Pyre is an object-oriented environment capable of specifying and launching
 numerical simulations on multiple platforms, including Beowulf class parallel
 computers and grid computing systems.
 Pyre allows the binding of multiple components such as solid and fluid
 models used in Earth science simulations, and different meshers.
 The Pyre framework enables the elegant setup, modification and launching
 of massively parallel three-dimensional solver applications.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Caption
Pyre Architecture.
 The integration framework is a set of cooperating abstract services.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figs/pyre_overview.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pyre is a framework, a combination of software and design philosophy that
 promotes the reuse of code.
 In their canonical software design book, 
\emph on
Design Patterns
\emph default
, Erich Gamma 
\shape italic
et al
\shape default
.
 condense the concept of a framework concept down to, ``When you use a framework
, you reuse the main body and write the code it calls.'' In the context of
 frameworks and object-oriented programming, Pyre can be thought of as a
 collection of classes and the way their instances interact.
 Programming applications based on Pyre will look similar to those written
 in any other object-oriented language.
 The Pyre framework contains a subset of parts that make up the overall
 framework.
 Each of those parts is designed to solve a specific problem.
\end_layout

\begin_layout Standard
The framework approach to computation offers many advantages.
 It permits the exchange of codes and promotes the reuse of standardized
 software while preserving efficiency.
 Frameworks are also an efficient way to handle changes in computer architecture.
 They present programmers and scientists with a unified and well-defined
 task and allow for shared costs of the housekeeping aspects of software
 development.
 They provide greater institutional continuity to model development than
 piecemeal approaches.
\end_layout

\begin_layout Standard
The Pyre framework incorporates features aimed at enabling the scientific
 non-expert to perform tasks easily without hindering the expert.
 Target features for end users allow complete and intuitive simulation specifica
tion, reasonable defaults, consistency checks of input, good diagnostics,
 easy access to remote facilities, and status monitoring.
 Target features for developers include easy access to user input, a shorter
 development cycle, and good debugging support.
\end_layout

\begin_layout Section
PyLith Design
\end_layout

\begin_layout Standard
[
\series bold
BRAD, MATT
\series default
 -- This section needs to be completely rewritten, since it came from PyLith
 0.8.
 Any help would be appreciated.]
\end_layout

\begin_layout Standard
In rewriting PyLith, the code was completely redesigned to be object-oriented
 and modular.
 Each module has its own facilities and parameters that may be specified
 in a number of different ways.
 This code structure will also simplify code maintenance and developement.
 We provide unit tests for all significant code funtions, which simplifies
 the task of diagnosing problems.
 Extending the set of code features is also easier, since developers can
 create new classes derived from the existing ones.
\end_layout

\begin_layout Standard
The new code design has also allowed us to make better use of the PETSc
 Sieve structure to handle mesh topology.
 ***NEED TO REWRITE THIS SECTION***In transforming Lithomop, a serial code,
 into PyLith, a parallel code, a principal concern was to preserve the existing
 structure of the serial Fortran code.
 Active development of purely analytic features in PyLith, such as new material
 models or discretization schemes, depends on the familiarity of application
 scientists with the traditional Fortran programming paradigm.
 Global, topological operations such as parallel assembly were strictly
 segregated from the preexisting code.
 In fact, PyLith can be run purely in serial without activating any of the
 parallel capabilities.
\end_layout

\begin_layout Standard
In order to accomplish this separation in version 0.8, we use the PETSc 
\family typewriter
Sieve
\family default
 structure to create a model of the serial PyLith mesh.
 This model is then partitioned and distributed to a set of processes.
 Each process receives a self-consistent mesh, meaning the pieces are overlappin
g, and then executes a serial PyLith step on that particular mesh piece.
 The PETSc assembles these pieces, using the 
\family typewriter
Sieve
\family default
 information, into globally consistent vectors and matrices.
\end_layout

\begin_layout Standard
Our new design begins with the
\family typewriter
 Sieve
\family default
 to represent the topology of our domain.
 Zero volume elements are inserted along all fault surfaces which can implement
 both split node and cohesive element schemes.
 Material properties and other parameters are represented as
\family typewriter
 Sections
\family default
 over the sieve, and values can be retrieved by restriction.
 For each problem, methods are provided to calculate the residual and its
 Jacobian.
 All analytic work is done in these functions, and parallel assembly is
 accomplished using the restrict/update paradigm from the
\family typewriter
 Sieve
\family default
 framework.
 We assemble into PETSc linear algebra objects and then call PETSc solvers.
 The solution is mapped back into a section, which can be output in VTK
 format.
\end_layout

\end_body
\end_document
