#LyX 1.4.4 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\begin_preamble

\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 2in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
PyLith is a multi-scale simulation software package for earthquake physics.
 It is portable, scalable software for simulation of crustal deformation
 across spatial scales ranging from meters to hundreds of kilometers and
 temporal scales ranging from milliseconds to thousands of years.
\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
This version of PyLith (1.0) is the first version to allow the solution of
 both implicit (quasi-static) and explicit (dynamic) problems, and represents
 a complete rewrite of the original PyLith.
 This version combines the functionality of EqSim [ref???] and PyLith 0.8.
 PyLith 0.8 was a direct descendant of LithoMop and was the first version
 that ran in parallel, as well as providing several other improvements over
 LithoMop.
 LithoMop was the product of major reengineering of Tecton, a finite-element
 code for simulating static and quasi-static crustal deformation.
 The major new features present in Lithomop included dynamic memory allocation
 and the use of the Pyre simulation framework and PETSc solvers.
 EqSim was written by Brad Aaagaard to solve problems in earthquake dynamics,
 including rupture propagaion and seismic wave propagation.
\end_layout

\begin_layout Standard
This release of PyLith allows the solution of both quasi-static and dynamic
 problems in 1, 2, or 3 dimensions.
 The code runs in either serial or parallel mode, and the design should
 allow for relatively easy scripting using the Python programming language.
 Boundary conditions, material properties, and fault specifications are
 handled using a spatial database, which allows complex models to be easily
 specified.
 Model parameters are generally specified through the use of 
\family sans
.cfg
\family default
 files, although they can also be specified using 
\family typewriter
.pml
\family default
 files or from the command line.
 At present, mesh information may be provided using a simple ASCII format,
 and mesh data may also be imported from CUBIT or LaGriT, two widely-used
 meshing packages.
 The elements currently available include a linear beam (1D), linear triangles
 and quadrilaterals (2D), and linear tetrahedra and hexahedra (3D).
 Materials presently available include isotropic elastic and linear Maxwell
 viscoelastic.
 Faults???
\end_layout

\begin_layout Standard
PyLith is under active development and we expect a number of additions and
 improvements in the near future.
 Likely enhancements will include the addition of new material models for
 both volume elements and cohesive (fault) elements, higher-order elements,
 and the generation of Green's functions to be used in inversions.
 Many of these features should be available by late Summer, 2007.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Software Components
\end_layout

\begin_layout Standard
PyLith is separated into modules to encapsulate behavior and facilitate
 use across multiple applications.
 That way expert users can replace functionality of a wide variety of components
 without recompiling or polluting the main code.
 External packages reduce development time and enhance computational efficiency;
 for example, PyLith 0.8 ran 2
\begin_inset Formula $\times$
\end_inset

 faster when the PETSc linear solver was used.
\end_layout

\begin_layout Standard
PyLith is based on two programming languages.
 High-level code is written in Python; this rich, expressive interpreted
 language with dynamic typing reduces development time.
 Low-level code is written in C++, providing fast execution while still
 allowing object-oriented code.
 We also make extensive use of two Python packages.
 Pyrex is a package that simplifies the task of adding C extensions to Python
 code.
 We also use pyrexembed, which extends the use of Pyrex to handle C++ code.
\end_layout

\begin_layout Standard
PyLith makes extensive use of external software.
 Pyre is a science-neutral simulation framework being developed at Caltech.
 PETSc is used to perform operations on matrices and vectors in parallel.
\end_layout

\begin_layout Subsection
PETSc
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \htmlurl[PETSc]{www-unix.mcs.anl.gov/petsc/petsc-as}

\end_inset

, the Portable, Extensible Toolkit for Scientific computation, provides
 a suite of routines for parallel, numerical solution of partial differential
 equations for linear and nonlinear systems with large, sparse systems of
 equations.
 PETSc includes solvers that implement a variety of Newton and Krylov subspace
 methods.
 It can also interface with many external packages, including BlockSolve95,
 ESSL, Matlab, ParMeTis, PVODE, and SPAI, thereby providing additional solvers
 and interaction with other software packages.
\end_layout

\begin_layout Standard
PETSc includes interfaces for Fortran, C, and C++ for nearly all of the
 routines, and PETSc can be installed on most Unix systems.
 PETSc can be built with user-supplied, highly optimized linear algebra
 routines (e.g., ATLAS and commercial versions of BLAS/LAPACK), thereby improving
 application performance.
 Users can use PETSc parallel matrices, vectors, and other data structures
 for most parallel operations, eliminating the need for explicit calls to
 Message Passing Interface (MPI) routines.
 Many settings and options can be controlled with PETSc-specific command-line
 arguments, including selection of preconditions, solvers, and generation
 of performance logs.
\end_layout

\begin_layout Standard
PyLith 0.8 and PyLith 1.0 make use of a new aspect of PETSc known as 
\family typewriter
Sieve
\family default
, which is still under active development.
 
\family typewriter
Sieve
\family default
 is a new method for representing computational meshes, and it greatly simplifie
s the task of code parallelization.
 
\family typewriter
Sieve
\family default
 also provides a number of other useful features, such as the ability to
 grab ``sections'' of a mesh that share common characteristics, such as
 elements of the same material type or nodes to which boundary conditions
 have been applied.
 This version of PyLith uses 
\family typewriter
Sieve
\family default
 much more extensively than PyLith 0.8, and should provide significantly
 better performance.
\end_layout

\begin_layout Subsection
Pyre
\end_layout

\begin_layout Standard
Pyre is an object-oriented environment capable of specifying and launching
 numerical simulations on multiple platforms, including Beowulf class parallel
 computers and grid computing systems.
 Pyre allows the binding of multiple components such as solid and fluid
 models used in Earth science simulations, and different meshers.
 The Pyre framework enables the elegant setup, modification and launching
 of massively parallel three-dimensional solver applications.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Caption
Pyre Architecture.
 The integration framework is a set of cooperating abstract services.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figs/pyre_overview.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pyre is a framework, a combination of software and design philosophy that
 promotes the reuse of code.
 In their canonical software design book, 
\emph on
Design Patterns
\emph default
, Erich Gamma 
\shape italic
et al
\shape default
.
 condense the concept of a framework concept down to, ``When you use a framework
, you reuse the main body and write the code it calls.'' In the context of
 frameworks and object-oriented programming, Pyre can be thought of as a
 collection of classes and the way their instances interact.
 Programming applications based on Pyre will look similar to those written
 in any other object-oriented language.
 The Pyre framework contains a subset of parts that make up the overall
 framework.
 Each of those parts is designed to solve a specific problem.
\end_layout

\begin_layout Standard
The framework approach to computation offers many advantages.
 It permits the exchange of codes and promotes the reuse of standardized
 software while preserving efficiency.
 Frameworks are also an efficient way to handle changes in computer architecture.
 They present programmers and scientists with a unified and well-defined
 task and allow for shared costs of the housekeeping aspects of software
 development.
 They provide greater institutional continuity to model development than
 piecemeal approaches.
\end_layout

\begin_layout Standard
The Pyre framework incorporates features aimed at enabling the scientific
 non-expert to perform tasks easily without hindering the expert.
 Target features for end users allow complete and intuitive simulation specifica
tion, reasonable defaults, consistency checks of input, good diagnostics,
 easy access to remote facilities, and status monitoring.
 Target features for developers include easy access to user input, a shorter
 development cycle, and good debugging support.
\end_layout

\begin_layout Section
PyLith Design
\end_layout

\begin_layout Standard
In rewriting PyLith, the code was completely redesigned to be object-oriented
 and modular.
 Each module has its own facilities and parameters that may be specified
 in a number of different ways.
 This code structure will also simplify the tasks of code maintenance and
 developement.
 We provide unit tests for all significant code funtions, which simplifies
 the task of diagnosing problems.
 Extending the set of code features is also easier, since developers can
 create new classes derived from the existing ones.
\end_layout

\begin_layout Standard
The new code design has also allowed us to make better use of the PETSc
 Sieve structure to handle mesh topology.
 ***NEED TO REWRITE THIS SECTION***In transforming Lithomop, a serial code,
 into PyLith, a parallel code, a principal concern was to preserve the existing
 structure of the serial Fortran code.
 Active development of purely analytic features in PyLith, such as new material
 models or discretization schemes, depends on the familiarity of application
 scientists with the traditional Fortran programming paradigm.
 Global, topological operation should be strictly segregated from the existing
 code.
 In fact, with the exception of integrating PETSc for serial linear algebra
 and solver operations, PyLith can be run purely in serial without activating
 any of the parallel capabilities.
\end_layout

\begin_layout Standard
In order to accomplish this separation, we use the PETSc 
\family typewriter
Sieve
\family default
 structure to create a model of the serial PyLith mesh.
 This model is then partitioned and distributed to a set of processes.
 Each process receives a self-consistent mesh, meaning the pieces are overlappin
g.
 Each process then executes a serial PyLith step on that particular mesh
 piece.
 The PETSc linear algebra operations are overloaded, using the 
\family typewriter
Sieve
\family default
 information, to produce a globally consistent field.
\end_layout

\end_body
\end_document
