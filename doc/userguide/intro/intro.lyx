#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\begin_preamble

\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 2in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
PyLith is a multi-scale simulation software package for earthquake physics.
 It is portable, scalable software for simulation of crustal deformation
 across spatial scales ranging from meters to hundreds of kilometers and
 temporal scales ranging from milliseconds to thousands of years.
\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
This version of PyLith (1.0) is the first version to allow the solution of
 both implicit (quasi-static) and explicit (dynamic) problems, and represents
 a complete rewrite of the original PyLith.
 This version combines the functionality of EqSim 
\begin_inset LatexCommand \cite{Aagaard:etal:2001a,Aagaard:etal:2001b}

\end_inset

 and PyLith 0.8.
 PyLith 0.8 was a direct descendant of LithoMop and was the first version
 that ran in parallel, as well as providing several other improvements over
 LithoMop.
 LithoMop was the product of major reengineering of Tecton, a finite-element
 code for simulating static and quasi-static crustal deformation.
 The major new features present in Lithomop included dynamic memory allocation
 and the use of the Pyre simulation framework and PETSc solvers.
 EqSim was written by Brad Aagaard to solve problems in earthquake dynamics,
 including rupture propagaiton and seismic wave propagation.
\end_layout

\begin_layout Standard
This release of PyLith allows the solution of both quasi-static and dynamic
 problems in one, two, or three dimensions.
 The code runs in either serial or parallel mode, and the design allows
 for relatively easy scripting using the Python programming language.
 Material properties and parameters for boundary and fault conditions are
 specified using a spatial database, which permits easy prescription of
 complex spatial variations of properties and parameters.
 Simulation parameters are generally specified through the use of simple
 ASCII files or the command line.
 At present, mesh information may be provided using a simple ASCII file
 (PyLith mesh ASCII format) or imported from CUBIT or LaGriT, two widely-used
 meshing packages.
 The elements currently available include a linear bar in 1D, linear triangles
 and quadrilaterals in 2D, and linear tetrahedra and hexahedra in 3D.
 Higher-order (quadratic) elements are also supported, but it is not presently
 possible to create a quadratic mesh from the linear meshes provided by
 most meshing packages.
 Materials presently available include isotropic elastic and linear Maxwell
 viscoelastic (3D only).
 Cohesive elements are used to implement slip across interior surfaces (faults).
 At present, only kinematically-specified fault slip is available.
 In the near future, we will provide several constitutive models for cohesive
 elements, which will allow slip to occur using various fault constitutive
 models.
\end_layout

\begin_layout Standard
PyLith is under active development and we expect a number of additions and
 improvements in the near future.
 Likely enhancements will include a more complete set of boundary conditions
 (absorbing boundaries for use in dynamic modeling and traction boundary
 conditions for use in quasi-static modeling), additional constitutive models
 for both volume elements and cohesive (fault) elements, automatic generation
 of higher-order elements from linear elements, and the generation of Green's
 functions to be used in inversions.
 Many of these features should be available in Fall 2007.
\end_layout

\begin_layout Section
PyLith Workflow
\end_layout

\begin_layout Standard
PyLith is one component in the process of investigating problems in tectonics
 (Figure 
\begin_inset LatexCommand \ref{fig:Workflow-summary}

\end_inset

).
 Given a geological problem of interest, a scientist must first provide
 a geometrical representation of the desired structure.
 Once the structure has been defined, a computational mesh must be created.
 Since there are a wide variety of mesh formats, this information must then
 be translated into something that the computational physics code can understand.
 PyLith presently provides three mesh importing options: CUBIT Exodus format,
 LaGriT GMV + Pset files, and PyLith mesh ASCII format.
 The modeling of the physical processes of interest is performed by a code
 such as PyLith.
 Once the computations have been performed, the results must be exported
 into a format that can be used by a visualization code.
 Present output consists of VTK files which can be used by a number of visualiza
tion codes (e.g., ParaView and MayaVi).
 In the near future, a more flexible HDF5 format is planned.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figs/workflow.eps
	scale 67
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:Workflow-summary}

\end_inset

Workflow involved in going from geologic structure to problem analysis.
\end_layout

\end_inset


\end_layout

\begin_layout Section
PyLith Design
\end_layout

\begin_layout Standard
PyLith is separated into modules to encapsulate behavior and facilitate
 use across multiple applications.
 This allows expert users to replace functionality of a wide variety of
 components without recompiling or polluting the main code.
 PyLith employs external packages to reduce development time and enhance
 computational efficiency; for example, PyLith 0.8 ran two times faster when
 the PETSc linear solver was used.
\end_layout

\begin_layout Standard
PyLith is written in two programming languages.
 High-level code is written in Python; this rich, expressive interpreted
 language with dynamic typing reduces development time and permits flexible
 addition of user-contributed modules.
 This high-level code makes use of Pyre, a science-neutral simulation framework
 developed at Caltech, to link the modules together at runtime and gather
 user-input.
 Low-level code is written in C++, providing fast execution while still
 allowing an object-oriented implementation.
 This low-level code relies on PETSc to perform operations on matrices and
 vectors in parallel.
 We also make extensive use of two Python packages.
 Pyrex is a package that simplifies the task of adding C extensions to Python
 code, and pyrexembed extends Pyrex to handle C++ code.
\end_layout

\begin_layout Standard
In writing PyLith 1.0, the code was completely redesigned to be object-oriented
 and modular.
 Each type of module is accessed through a specified interface (set of functions
).
 This permits adding, replacing, and rewriting modules without affecting
 other parts of the code.
 This code structure simplifies code maintenance and developement.
 Extending the set of code features is also easier, since developers can
 create new modules derived from the existing ones.
\end_layout

\begin_layout Standard
The new code design leverages Pyre, Sieve, and PETSc much more extensively
 than the previous version.
 Pyre is used to glue together the various modules used to construct a simulatio
n and specify the simulation parameters.
 Sieve is used for all finite-element storage and manipulation and handles
 the creation of the PETSc matrices and vectors.
 As a result, most of the PyLith source code pertains to implementing the
 geodynamics, such as bulk rheology, boundary conditions, and slip on faults.
 
\end_layout

\begin_layout Standard
During development, tests were constructed for nearly every module function.
 These unit tests are distributed with the source code.
 These tests are run continuously during development to expose bugs and
 isolate their origin.
 As additional changes are made to the code, the tests are rerun to help
 prevent introduction of bugs.
 A number of simple, full scale tests, such as axial compression, simple
 shear, and slip between two cells, have been used to test the code.
\end_layout

\begin_layout Standard
Our new design begins with the
\family typewriter
 Sieve
\family default
 to represent the topology of our domain.
 Zero volume elements are inserted along all fault surfaces which can implement
 both kinematic (prescribed) and dynamic (constitutive model) implementations
 of fault slip.
 Material properties and other parameters are represented as sections (scalar
 and vector fields) over the mesh, and values for a vertex or cell can be
 retrieved by restricting the section to the vertex or cell.
 For each problem, functions are provided to calculate the residual and
 its Jacobian.
 All numerical integration is done in these functions, and parallel assembly
 is accomplished using the restrict/update paradigm of the
\family typewriter
 Sieve
\family default
 framework.
 We assemble into PETSc linear algebra objects and then call PETSc solvers.
 The solution is mapped back into a section, which can be output in VTK
 format.
\end_layout

\begin_layout Subsection
Pyre
\end_layout

\begin_layout Standard
Pyre is an object-oriented environment capable of specifying and launching
 numerical simulations on multiple platforms, including Beowulf class parallel
 computers and grid computing systems.
 Pyre allows the binding of multiple components such as solid and fluid
 models used in Earth science simulations, and different meshers.
 The Pyre framework enables the elegant setup, modification and launching
 of massively parallel solver applications.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Caption
Pyre Architecture.
 The integration framework is a set of cooperating abstract services.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figs/pyre_overview.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pyre is a framework, a combination of software and design philosophy that
 promotes the reuse of code.
 In their canonical software design book, 
\emph on
Design Patterns
\emph default
, Erich Gamma 
\shape italic
et al
\shape default
.
 condense the concept of a framework concept down to, ``When you use a framework
, you reuse the main body and write the code it calls.'' In the context of
 frameworks and object-oriented programming, Pyre can be thought of as a
 collection of classes and the way their instances interact.
 Programming applications based on Pyre will look similar to those written
 in any other object-oriented language.
 The Pyre framework contains a subset of parts that make up the overall
 framework.
 Each of those parts is designed to solve a specific problem.
\end_layout

\begin_layout Standard
The framework approach to computation offers many advantages.
 It permits the exchange of codes and promotes the reuse of standardized
 software while preserving efficiency.
 Frameworks are also an efficient way to handle changes in computer architecture.
 They present programmers and scientists with a unified and well-defined
 task and allow for shared costs of the housekeeping aspects of software
 development.
 They provide greater institutional continuity to model development than
 piecemeal approaches.
\end_layout

\begin_layout Standard
The Pyre framework incorporates features aimed at enabling the scientific
 non-expert to perform tasks easily without hindering the expert.
 Target features for end users allow complete and intuitive simulation specifica
tion, reasonable defaults, consistency checks of input, good diagnostics,
 easy access to remote facilities, and status monitoring.
 Target features for developers include easy access to user input, a shorter
 development cycle, and good debugging support.
\end_layout

\begin_layout Subsection
Sieve and PETSc
\end_layout

\begin_layout Standard
PyLith 0.8 and PyLith 1.0 make use of a new set of data structures and routines
 in PETSc called 
\family typewriter
Sieve
\family default
, which is still under active development.
 
\family typewriter
Sieve
\family default
 is a new method for representing computational meshes, and it greatly simplifie
s finite-element computations.
 
\family typewriter
Sieve
\family default
 provides a number of useful features, such as the ability to grab ``sections''
 of a mesh that share common characteristics, such as cells of the same
 material type or vertices to which boundary conditions need to be applied.
 This version of PyLith uses 
\family typewriter
Sieve
\family default
 much more extensively than PyLith 0.8, and should provide significantly
 better performance.
 Sieve interfaces with PETSc for solving the system of equations.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \htmlurl[PETSc]{www-unix.mcs.anl.gov/petsc/petsc-as}

\end_inset

, the Portable, Extensible Toolkit for Scientific computation, provides
 a suite of routines for parallel, numerical solution of partial differential
 equations for linear and nonlinear systems with large, sparse systems of
 equations.
 PETSc includes solvers that implement a variety of Newton and Krylov subspace
 methods.
 It can also interface with many external packages, including ESSL, MUMPS,
 Matlab, ParMeTis, PVODE, and Hypre, thereby providing additional solvers
 and interaction with other software packages.
\end_layout

\begin_layout Standard
PETSc includes interfaces for Fortran 77/90, C, C++, and Python for nearly
 all of the routines, and PETSc can be installed on most Unix systems.
 PETSc can be built with user-supplied, highly optimized linear algebra
 routines (e.g., ATLAS and commercial versions of BLAS/LAPACK), thereby improving
 application performance.
 Users can use PETSc parallel matrices, vectors, and other data structures
 for most parallel operations, eliminating the need for explicit calls to
 Message Passing Interface (MPI) routines.
 Many settings and options can be controlled with PETSc-specific command-line
 arguments, including selection of preconditions, solvers, and generation
 of performance logs.
\end_layout

\end_body
\end_document
