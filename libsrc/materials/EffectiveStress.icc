// -*- C++ -*-
//
// ----------------------------------------------------------------------
//
//                           Brad T. Aagaard
//                        U.S. Geological Survey
//
// {LicenseText}
//
// ----------------------------------------------------------------------
//

#include <portinfo>

#include "petsc.h" // USES PetscLogFlops

#include <cmath> // USES fabs()
#include <cassert> // USES assert()
#include <stdexcept> // USES std::runtime_error

// ----------------------------------------------------------------------
// Get effective stress from initial guess.
template<typename material_type>
double
pylith::materials::EffectiveStress::calculate(
				 const double effStressInitialGuess,
				 const double stressScale,
				 material_type* const material)
{ // getEffStress
  // Check parameters
  assert(effStressInitialGuess >= 0.0);

  // Bracket the root.
  double x1 = 0.0;
  double x2 = 0.0;
  if (effStressInitialGuess > 0.0) {
    x1 = effStressInitialGuess - 0.5 * effStressInitialGuess;
    x2 = effStressInitialGuess + 0.5 * effStressInitialGuess;
  } else {
    x1 = stressScale - 0.5 * stressScale;
    x2 = stressScale + 0.5 * stressScale;
  } // else

  _bracket(&x1, &x2, material);

  // Find effective stress using Newton's method with bisection.
  const double effStress = _search(x1, x2, material);

  PetscLogFlops(4); // Log flops

  return effStress;
} // getEffStress

// ----------------------------------------------------------------------
// Bracket effective stress.
template<typename material_type>
void
pylith::materials::EffectiveStress::_bracket(double* px1,
					     double* px2,
					     material_type* const material)
{ // _bracket
  // Arbitrary number of iterations to bracket the root
  const int maxIterations = 50;

  // Arbitrary factor by which to increase the brackets.
  const double bracketFactor = 2;
  double x1 = *px1;
  double x2 = *px2;

  double funcValue1 = material->effStressFunc(x1);
  double funcValue2 = material->effStressFunc(x2);

  int iteration = 0;
  bool bracketed = false;
  while (iteration < maxIterations) {
    if ((funcValue1 * funcValue2) < 0.0) {
      bracketed = true;
      break;
    } // if

    if (fabs(funcValue1) < fabs(funcValue2)) {
      x1 += bracketFactor * (x1 - x2);
      x1 = std::max(x1, 0.0);
      funcValue1 = material->effStressFunc(x1);
    } else {
      x2 += bracketFactor * (x1 - x2);
      x2 = std::max(x2, 0.0);
      funcValue2 = material->effStressFunc(x2);
    } // else
    ++iteration;
  } // while

  *px1 = x1;
  *px2 = x2;

  PetscLogFlops(5 * iteration);
  if (!bracketed)
    throw std::runtime_error("Unable to bracket effective stress.");
} // _bracket

#include <iostrem> // TEMPORARY
// ----------------------------------------------------------------------
// Find root using Newton's method with bisection.
template<typename material_type>
double
pylith::materials::EffectiveStress::_search(const double x1,
					    const double x2,
					    material_type* const material)
{ // _search
  // Arbitrary number of iterations to find the root
  const int maxIterations = 100;

  // Desired accuracy for root. This is a bit arbitrary for now.
  const double accuracy = 1.0e-18;

  // Organize search so that effStressFunc(xLow) is less than zero.
  double funcValueLow = material->effStressFunc(x1);
  double funcValueHigh = material->effStressFunc(x2);
  assert(funcValueLow * funcValueHigh <= 0.0);

  double effStress = 0.0;
  double xLow = 0.0;
  double xHigh = 0.0;
  bool converged = false;

  if (funcValueLow < 0.0) {
    xLow = x1;
    xHigh = x2;
  } else {
    xLow = x2;
    xHigh = x1;
  } // if/else

  effStress = 0.5 * (x1 + x2);
  double dxPrevious = fabs(x2 - x1);
  double dx = dxPrevious;
  double funcValue = 0.0;
  double funcDeriv = 0.0;
  double funcXHigh = 0.0;
  double funcXLow = 0.0;
  material->effStressFuncDerivFunc(&funcValue, &funcDeriv, effStress);
  int iteration = 0;

  while (iteration < maxIterations) {
    funcXHigh = (effStress - xHigh) * funcDeriv - funcValue;
    funcXLow = (effStress - xLow) * funcDeriv - funcValue;
    std::cout << "low: " << funcXLow
	      << ", high: " << funcXHigh
	      << ", func: " << funcValue
	      << std::endl;
    if (fabs(funcValue) < accuracy) {
      converged = true;
      break;
    } // if
    // Use bisection if solution goes out of bounds or is not converging
    // fast enough.
    if ( (funcXHigh * funcXLow >= 0.0) ||
	 (fabs(2.0 * funcValue) > fabs(dxPrevious * funcDeriv))) {
      dxPrevious = dx;
      dx = 0.5 * (xHigh - xLow);
      effStress = xLow + dx;
    } else {
      dxPrevious = dx;
      dx = funcValue / funcDeriv;
      effStress = effStress - dx;
    } // else
    material->effStressFuncDerivFunc(&funcValue, &funcDeriv, effStress);
    if (funcValue < 0.0) {
      xLow = effStress;
    } else {
      xHigh = effStress;
    } // else
    ++iteration;
  } // while

  if (converged == false)
    throw std::runtime_error("Cannot find root of effective stress function.");

  PetscLogFlops(5 + 15 * iteration); // Log flops

  return effStress;
} // _search


// End of file 
