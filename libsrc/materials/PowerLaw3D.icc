// -*- C++ -*-
//
// ----------------------------------------------------------------------
//
//                           Brad T. Aagaard
//                        U.S. Geological Survey
//
// {LicenseText}
//
// ----------------------------------------------------------------------
//

#if !defined(pylith_materials_powerlaw3d_hh)
#error "PowerLaw3D.icc can only be included from PowerLaw3D.hh"
#endif

#include <assert.h> // USES assert()
#include "pylith/utils/macrodefs.h" // USES CALL_MEMBER_FN

// Set current time step.
inline
void
pylith::materials::PowerLaw3D::timeStep(const double dt) {
  // Not sure what to do here.  If we are using full Newton the Jacobian will
  // always need reforming, but SNES may opt not to reform it sometimes.
  _needNewJacobian = true;
  _dt = dt;
} // timeStep

// Set whether elastic or inelastic constitutive relations are used.
inline
void
pylith::materials::PowerLaw3D::useElasticBehavior(const bool flag,
						  const int iteration) {
  if (flag) {
    _calcStressFn = 
      &pylith::materials::PowerLaw3D::_calcStressElastic;
    _calcElasticConstsFn = 
      &pylith::materials::PowerLaw3D::_calcElasticConstsElastic;
    _updatePropertiesFn = 
      &pylith::materials::PowerLaw3D::_updatePropertiesElastic;
  } else {
    _calcStressFn = 
      &pylith::materials::PowerLaw3D::_calcStressViscoelastic;
    if (iteration == 0) {
      _calcElasticConstsFn = 
	&pylith::materials::PowerLaw3D::_calcElasticConstsViscoelasticInitial;
    } else {
      _calcElasticConstsFn = 
	&pylith::materials::PowerLaw3D::_calcElasticConstsViscoelastic;
    }
    _updatePropertiesFn = 
      &pylith::materials::PowerLaw3D::_updatePropertiesViscoelastic;
  } // if/else
} // useElasticBehavior

// Get flag indicating whether material implements an empty
inline
bool
pylith::materials::PowerLaw3D::usesUpdateProperties(void) const {
  return true;
} // usesUpdateProperties

// Compute stress tensor from parameters.
inline
void
pylith::materials::PowerLaw3D::_calcStress(double* const stress,
						   const int stressSize,
						   const double* parameters,
						   const int numParams,
						   const double* totalStrain,
						   const int strainSize,
						   const double* initialState,
						   const int initialStateSize,
						   const bool computeStateVars) {
  assert(0 != _calcStressFn);
  CALL_MEMBER_FN(*this, _calcStressFn)(stress, stressSize, 
				       parameters, numParams,
				       totalStrain, strainSize,
				       initialState, initialStateSize,
				       computeStateVars);
} // _calcStress

// Compute derivatives of elasticity matrix from parameters.
inline
void
pylith::materials::PowerLaw3D::_calcElasticConsts(
						 double* const elasticConsts,
						 const int numElasticConsts,
						 const double* parameters,
						 const int numParams,
						 const double* totalStrain,
						 const int strainSize,
						 const double* initialState,
						 const int initialStateSize) {
  assert(0 != _calcElasticConstsFn);
  CALL_MEMBER_FN(*this, _calcElasticConstsFn)(elasticConsts, numElasticConsts,
					      parameters, numParams,
					      totalStrain, strainSize,
					      initialState, initialStateSize);
} // _calcElasticConsts

// Update state variables after solve.
inline
void
pylith::materials::PowerLaw3D::_updateProperties(double* const parameters,
						    const int numParams,
						    const double* totalStrain,
						    const int strainSize,
						    const double* initialState,
						    const int initialStateSize) {
  assert(0 != _updatePropertiesFn);
  CALL_MEMBER_FN(*this, _updatePropertiesFn)(parameters, numParams,
					     totalStrain, strainSize,
					     initialState, initialStateSize);
} // _updateProperties

// Compute scalar product, assuming vector form of a tensor.
inline
double
pylith::materials::PowerLaw3D::_scalarProduct(const double* tensor1,
					      const double* tensor2)
{
  const double scalarProduct = tensor1[0] * tensor2[0] +
    tensor1[1] * tensor2[1] +
    tensor1[2] * tensor2[2] +
    2.0 * (tensor1[3] * tensor2[3] +
	   tensor1[4] * tensor2[4] +
	   tensor1[5] * tensor2[5]);
  return scalarProduct;
} // _scalarProduct

// End of file 
