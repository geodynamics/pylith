// -*- C++ -*-
//
// ======================================================================
//
// Brad T. Aagaard, U.S. Geological Survey
// Charles A. Williams, GNS Science
// Matthew G. Knepley, University of Chicago
//
// This code was developed as part of the Computational Infrastructure
// for Geodynamics (http://geodynamics.org).
//
// Copyright (c) 2010-2013 University of California, Davis
//
// See COPYING for license information.
//
// ======================================================================
//

#if !defined(pylith_topology_submesh_hh)
#error "SubMesh.icc must be included only from SubMesh.hh"
#else

#include "pylith/utils/error.h" // USES PYLITH_CHECK_ERROR

// Get Sieve mesh.
inline
const ALE::Obj<pylith::topology::Mesh::SieveSubMesh>&
pylith::topology::SubMesh::sieveMesh(void) const {
  return _mesh;
}

// Get Sieve mesh.
inline
ALE::Obj<pylith::topology::Mesh::SieveSubMesh>&
pylith::topology::SubMesh::sieveMesh(void) {
  return _mesh;
}

// Get DMComplex mesh.
inline
PetscDM
pylith::topology::SubMesh::dmMesh(void) const {
  return _newMesh;
}

// Set DMComplex mesh.
inline
void
pylith::topology::SubMesh::setDMMesh(PetscDM dm) {
  PetscErrorCode err;
  err = DMDestroy(&_newMesh);PYLITH_CHECK_ERROR(err);
  _newMesh = dm;
  err = PetscObjectSetName((PetscObject) _newMesh, "domain");PYLITH_CHECK_ERROR(err);
}

// Get point type sizes.
inline
void
pylith::topology::SubMesh::getPointTypeSizes(PetscInt *numNormalCells,
					     PetscInt *numCohesiveCells,
					     PetscInt *numNormalVertices,
					     PetscInt *numShadowVertices,
					     PetscInt *numLagrangeVertices) const {
  *numNormalCells = 0;
  *numCohesiveCells = 0;
  *numNormalVertices = 0;
  *numShadowVertices = 0;
  *numLagrangeVertices = 0;
}

// Get coordinate system.
inline
const spatialdata::geocoords::CoordSys*
pylith::topology::SubMesh::coordsys(void) const {
  return _coordsys;
}

// Set debug flag.
inline
void
pylith::topology::SubMesh::debug(const bool value) {
  _debug = value;
  if (!_mesh.isNull())
    _mesh->setDebug(value);
}

// Get debug flag.
inline
bool
pylith::topology::SubMesh::debug(void) const {
  return _debug;
}

// Get dimension of mesh.
inline
int
pylith::topology::SubMesh::dimension(void) const {
  PetscInt dim = 0;
  if (_newMesh) {
    PetscErrorCode err = DMPlexGetDimension(_newMesh, &dim);PYLITH_CHECK_ERROR(err);
  } // if
  return dim;
}

// Get representative cone size for mesh.
inline
int
pylith::topology::SubMesh::coneSize(void) const {
  PetscInt coneSize = 0;
  if (_newMesh) {
    PetscErrorCode err;
    PetscInt cStart = 0;
    err = DMPlexGetHeightStratum(_newMesh, 1, &cStart, NULL);PYLITH_CHECK_ERROR(err);
    err = DMPlexGetConeSize(_newMesh, cStart, &coneSize);PYLITH_CHECK_ERROR(err);
  } // if
  return coneSize;
}

// Get number of vertices in mesh.
inline
int
pylith::topology::SubMesh::numVertices(void) const {
  PetscInt nvertices = 0;
  if (_newMesh) {
    PetscInt begin=0, end=0;
    PetscErrorCode err = DMPlexGetDepthStratum(_newMesh, 0, &begin, &end);PYLITH_CHECK_ERROR(err);
    nvertices = end-begin;
  } // if
  return nvertices;
}

// Get number of cells in mesh.
inline
int
pylith::topology::SubMesh::numCells(void) const {
  PetscInt ncells = 0;
  if (_newMesh) {
    PetscInt begin=0, end=0;
    PetscErrorCode err = DMPlexGetHeightStratum(_newMesh, 1, &begin, &end);PYLITH_CHECK_ERROR(err);
    ncells = end-begin;
  } // if
  return ncells;
}

// Get MPI communicator associated with mesh.
inline
const MPI_Comm
pylith::topology::SubMesh::comm(void) const {
  MPI_Comm comm;
  if (_newMesh) {
    PetscErrorCode err = PetscObjectGetComm((PetscObject)_newMesh, &comm);
  } // if
  return comm;
} // if
    
// Print mesh to stdout.
inline
void
pylith::topology::SubMesh::view(const char* label) const {
  assert(_newMesh);
  PetscErrorCode err = DMView(_newMesh, PETSC_VIEWER_STDOUT_WORLD);PYLITH_CHECK_ERROR(err);
}


#endif


// End of file
